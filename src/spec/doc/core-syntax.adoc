[[_syntax]]
= 语法

这个章节主要涵盖 Groovy 编程语言的语法(syntax). Groovy 的语法(grammar)派生自(derives from)
Java 的语法, 但是针对 Groovy 的具体结构做了增强, 并允许一定的简化.

[[_comments]]
== 注释

[[_single_line_comment]]
=== 单行注释

单行注释由 +//+ 开始, 允许出现在一行的任意位置. +//+ 之后换行符之前的字符都被认为是注释的一部分.

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=single_line_comment,indent=0]
----

[[_multiline_comment]]
=== 多行注释

多行注释以 +/\*+ 开始, 可以出现在一行的任意位置. +/*+ 之后的字符会被认为是注释的一部分,
包括换行符, 直到第一个 +*/+ 元素. 因此多行注释可以放在语句之后, 甚至语句之间.

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=multiline_comment,indent=0]
----

[[_groovydoc_comment]]
=== GroovyDoc 注释

与多行注释类似, GroovyDoc 也是多行的, 但以 +/\**+ 开始, 以 +*/+ 结束.
首行注释之后的行可以以可选的 +*+ 号开始. 这些注释关联于:

* 类型定义(类, 接口, 枚举, 注解)
* 字段和属性定义
* 方法定义

对以上元素, 即使没有 GroovyDoc 编译器也不会抱怨, 但应优先考虑使用该注释.

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=groovydoc_comment,indent=0]
----

GroovyDoc 遵循 JavaDoc 的约定(conventions), 因此你可以使用 JavaDoc 中的标签(tags).

=== Shebang line

单行注释之外还有一个特殊的行注释, 在 Unix 系统下通常称为 _shebang line_, 它允许脚本直接
从命令行启动, 前提是已安装了 Groovy 并且 +groovy+ 命令包含在 +PATH+ 环境变量中.

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=shebang_comment_line,indent=0]
----

NOTE: +#+ 字符必须是文件的第一个字符, 任何缩进都会导致一个编译错误.

[[_keywords]]
== 关键字

下表列出了 Groovy 中的所有关键字:

[cols="1,1,1,1"]
.关键字
|===
|as
|assert
|break
|case

|catch
|class
|const
|continue

|def
|default
|do
|else

|enum
|extends
|false
|finally

|for
|goto
|if
|implements

|import
|in
|instanceof
|interface

|new
|null
|package
|return

|super
|switch
|this
|throw

|throws
|true
|try
|while

|===

[[_identifiers]]
== 标识符

[[_normal_identifiers]]
=== 普通标识符

标识符(identifiers)以字母, 美元符号($)或者下划线开始. 不能以数字开始.

字母的取值范围如下:

* 'a' 到 'z' (小写的 ascii 字母)
* 'A' 到 'Z' (大写的 ascii 字母)
* '\u00C0' 到 '\u00D6'
* '\u00D8' 到 '\u00F6'
* '\u00F8' 到 '\u00FF'
* '\u0100' 到 '\uFFFE'

之后的字符可以包含字母或者数字.

以下是一些有效标识符示例(变量名):

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=valid_identifiers,indent=0]
----

但是以下的标识符是无效的:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=invalid_identifiers,indent=0]
----

点号之后的所有关键字也是无效的标识符:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=keywords_valid_id_after_dot,indent=0]
----

[[_quoted_identifiers]]
=== 引用标识符

引用标识符(quoted identifiers)位于点表达式(dotted expression)的点号之后.
例如, 表达式 +person.name+ 的 +name+ 部分可以像 +person."name"+ 或者 +person.\'name\'+ 那样添加引号.
这相当有趣, 当某些标识符包含 Java 语言规范(Java Language Specification)所禁止的非法字符时,
在 Groovy 中通过添加引号是被允许的. 如 破择号(dash), 空格, 感叹号等.

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=quoted_id,indent=0]
----

我们将会在<<all-strings, 之后的字符串章节>>中看到, Groovy 提供了不同的 字符串字面量(literals).
点号之后所有类型的字符串都是允许的.

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=quoted_id_with_all_strings,indent=0]
----

普通字符串和 Groovy 的 GStrings(interpolated strings, 插值字符串)是有区别的,
对于后者, 在判断(evaluating)整个标识符时插值会被插入到最终的字符串中:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=quoted_id_with_gstring,indent=0]
----

[[all-strings]]
== 字符串

// @TODO
// Text literals are represented in the form of chain of characters called strings.
文本也即字符串, 以字符链的形式表示.
Groovy 允许你实例化 +java.lang.String+ 和 GStrings (+groovy.lang.GString+)对象, GStrings
在其他语言中称为 _插值字符串_.

[[_single_quoted_string]]
=== 单引号字符串

单引号字符串即由单引号包围的一系列字符:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=quoted_id_with_gstring,indent=0]
----

NOTE: 单引号字符串是 +java.lang.String+, 不支持插值.

[[_string_concatenation]]
=== 字符串拼接

Groovy 中的所有字符串都可以用 `+` 操作符来拼接(concatenation):

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=string_plus,indent=0]
----

[[_triple_single_quoted_string]]
=== 三单引号字符串

// @TODO 英文文档这里是否有问题, 或者还是翻译上的问题?
三单引号字符串即由单引号包围的一系列字符:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=string_1,indent=0]
----

NOTE: 三单引号字符串是 +java.lang.String+, 不支持插值.

三单引号字符串是多行的.
你可以用换行符分隔字符串内容, 而不用把字符串分割为多部分, 不用拼接字符串或者转义换行符.

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=triple_single_1,indent=0]
----

如果代码包含缩进, 如在类或者方法的主体(body)部分, 则字符串也会包含这些缩进的空白字符(whitespace).
可以通过 Groovy 开发工具(Development Kit) 中的 +String#stripIndent()+ 方法来移除这些缩进,
通过 +String#stripMargin()+ 方法, 传入一个分界字符(delimiter character)参数, 来指定要从字符串中移除的字符.

当创建如下的字符串:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=triple_single_2,indent=0]
----

你会发现结果字符串的第一个字符是一个换行符. 可以用反斜杠(backslash)转义换行符来移除该字符:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=triple_single_3,indent=0]
----

[[_escaping_special_characters]]
==== 转义特殊字符

可以用反斜杠来转义单引号以避免终止(terminating)字符串字面量:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=string_2,indent=0]
----

可以用两个反斜杠来转义转义符本身:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=string_3,indent=0]
----

一些特殊字符也使用反斜杠当做转义符:

[cols="1,2" options="header"]
|====
|转义序列
|字符

|'\t'
|水平制表

|'\b'
|退格

|'\n'
|换行

|'\r'
|回车

|'\f'
|换页

|'\\'
|反斜杠字符 '\'

|'\''
|单引号字符 (单引号或三单引号字符串中使用)

|'\"'
|双引号字符 (双引号或三双引号字符串中使用)
|====

[[_unicode_escape_sequence]]
==== Unicode 转义序列

那些没有出现在你键盘上的字符, 可以使用 unicode 转义序列来表示: 一个反斜杠, 之后是一个 'u',
然后是4个十六进制数字.

例如, 欧元货币符号可以这样表示:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=string_4,indent=0]
----

[[_double_quoted_string]]
=== 双引号字符串

双引号字符串即由双引号包围的一系列字符:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=string_5,indent=0]
----

NOTE: 在没有插入表达式(interpolated expression)的情况下双引号字符串为 +java.lang.String+;
如果有, 则为 +groovy.lang.GString+.

NOTE: 可以使用反斜杠字符来转义双引号, 如: +"A double quote: \""+.

[[_string_interpolation]]
==== 字符串插值

任何 Groovy 表达式都可以插入到所有的字符串字面量中, 除了单引号和三单引号字符串.
插值即把字符串中的占位符用其在对字符串求值(evaluation)中的值来替代的操作.
占位符表达式由 +${}+ 包围, 对点表达式可以以 +$+ 开头.
当 GString 传入到一个以 String 为参数的方法时, 占位符中的表达式会通过调用 +toString()+ 方法
将其值转换为对应的字符串表示.

这里, 我们有一个带有占位符的字符串, 该占位符引用了一个本地变量:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=gstring_1,indent=0]
----

Groovy 中的任何表达式都是有效的, 在这个例子中我们可以看到其带有一个算术表达式:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=gstring_2,indent=0]
----

[NOTE]
+${}+ 占位符中不仅仅允许表达式, 语句(statements)也是允许的, 但一个语句的值单纯(is just)为 +null+.
所以, 如果多个语句被插入到占位符中, 最后一个应该返回一个有意义的值.
例如, +"The sum of 1 and 2 is equal to ${def a = 1; def b = 2; a + b}"+ 是支持的同时也能
如预期的工作, 但坚持在 GString 占位符中使用简单的表达式是一个好习惯.

除了 +${}+ 占位符, 对于点表达式我们也可以使用一个单独的 +$+ 符号作为其前缀:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=gstring_3,indent=0]
----

但是只有形式如 +a.b+, +a.b.c+ 之类的是有效的, 表达式中含有括号如方法调用, 花括号如闭包,
算术操作符等都是无效的. 以下变量定义为一个数字:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=gstring_4,indent=0]
----

下面的语句会抛出 +groovy.lang.MissingPropertyException+ 异常, 因为 Groovy 认为你
试图访问 number 的 +toString+ 属性, 但是它是不存在的.

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=gstring_5,indent=0]
----

NOTE: 可以认为 +"$number.toString()"+ 被语法分析器(parser) 解释为 +"${number.toString}()"+.

如果你想在 GString 中转义 +$+ 或者 +${}+ 占位符, 让它们能显示而不会进行插值, 你只需要用
+\+ 反斜杠字符来转义美元符号:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=gstring_6,indent=0]
----

[[_special_case_of_interpolating_closure_expressions]]
==== 特例 插入闭包表达式

到目前为止, 我们看到可以在 +${}+ 占位符中放入任意的表达式, 但闭包是个特例并且有着特别的表示法.
当占位符包含一个箭头, +${\->}+, 该表达式即是一个闭包表达式 -- 你可以认为它是一个前面带有美元符号的闭包.

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=closure_in_gstring_1,indent=0]
----
<1> 该闭包是一个无参闭包, 不接受参数.
<2> 这里, 闭包接受一个 +java.io.StringWriter+ 参数, 可以用 +<<+ 左移操纵符来给它添加内容.
两种情况中, 占位符都是嵌入式闭包(embedded closures).

以这种方式定义插入的表达式显得更加冗长(verbose), 但与单纯的(mere)表达式相比, 闭包有一个
有趣的特性: 惰性求值(lazy evaluation).

让我们考虑下面的例子:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=closure_in_gstring_2,indent=0]
----
<1> 我们定义了一个 +number+ 变量, 值为 +1+, 然后我们它插入到2个 GStrings 中,
+eagerGString+ 中作为表达式, +lazyGString+ 中作为闭包.
<2> 对 +eagerGString+ 我们预期结果字符串包含有 1.
<3> +lazyGString+ 类似.
<4> 然后我们改变该变量, 为其赋一个新值.
<5> 对于单纯的(plain)插入表达式, 其值实际上是绑定到了 GString 创建时的值.
<6> 但是对闭包表达式, 每次强制(coercion)把 GString 转换为 String 的时候都会调用闭包,
其结果是生成一个包含有新值的新字符串.

[NOTE]
一个嵌入式闭包表达式接受超过1个参数将会在运行时抛出(generate)异常, 只有0或者1个参数的闭包是允许的.

[[_interoperability_with_java]]
==== 与 Java 交互

当一个方法(不管是在 Java 还是在 Groovy 中实现)期望(expects)一个 +java.lang.String+,
但我们传入一个 +groovy.lang.GString+ 实例时, GString 的 +toString()+ 方法会自动, 透明地被调用.

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=java_gstring_interop_1,indent=0]
----
<1> 我们创建了一个 GString 变量.
<2> 我们仔细检查它是一个 GString 实例.
<3> 然后我们把这个 GString 传入到接受 String 作为参数的方法.
<4> +takeString()+ 方法的签名明确声明(says)它唯一的参数是一个 String.
<5> 我们进一步核实该参数确实是个 String 而不是 GString.

[[_gstring_and_string_hashcodes]]
==== GString 和 String 的哈希码

尽管插值字符串可以用来代替普通 Java 字符串, 但它们与普通字符串在某一方面还是有区别的:
即它们的哈希码(hashCodes)是不一样的. 普通 Java 字符串是不可变的, 然而 GString 的结果字符串
表示是可变的, 取决于它的插入值. 即使结果字符串相同, GString 和 String 还是有不同的哈希码.

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=gstring_hashcode_1,indent=0]
----

GString 和 Strings 有着不一样的哈希码值, 所以应该避免把 GString 当做 Map 的键来用,
尤其是在检索关联值(associated value)时应该使用 String 而不是 GString.

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=gstring_hashcode_2,indent=0]
----
<1> 创建一个 map, 带有初始键值对(initial pair), 键为一个 GString.
<2> 当我们视图获取该 String 键所对应的值时, 会发现无法找到, 由于 String 和 GString 有着
不同的哈希码值.

[[_triple_double_quoted_string]]
=== 三双引号字符串

三双引号字符串类似(behave like)双引号字符串, 只是它们是多行的, 这点可类比三单引号字符串.

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=triple_double_1,indent=0]
----

NOTE: 在三双引号字符串中, 双引号跟单引号都不需要转义.

[[_slashy_string]]
=== 斜线字符串

除了通常的引号字符串, Groovy 还提供了 斜线字符串(slashy strings), 其使用 +/+ 作为定界符.
斜线字符串在定义正则表达式或者模式(patterns)时特别有用的, 因为不需要对反斜杠进行转义.

斜线字符串的示例:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=slashy_1,indent=0]
----

只有斜线需要用反斜杠来转义:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=slashy_2,indent=0]
----

斜线字符串是多行的:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=slashy_3,indent=0]
----

斜线字符串也可以插值(如, GString):

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=slashy_4,indent=0]
----

有几个陷阱需要注意.

不能用两个斜线来表示空(斜线)字符串, 因为它被 Groovy 语法分析器当做一个行注释来理解.
这是为什么下面的断言实际上会导致一个编译错误, 因为它看起来像一个没结束(non-terminated)的语句.

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=slashy_5,indent=0]
----

[[_dollar_slashy_string]]
=== 美元斜线字符串

美元斜线字符串(dollar slashy string)是以 +$/+ 开始, 以 +/$+ 结束的多行 GStrings.
转义字符为美元符号, 可以用来转义另一美元符号或者正斜杠.
但是美元符号跟正斜杠都可以不用转义, 除了像 GString 占位符那样的字符串序列需要对美元符号进行转义,
以及像美元斜线字符串关闭标签那样的字符序列进行转义.

请看下面的例子:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=dollar_slashy_1,indent=0]
----

[[_string_summary_table]]
=== 字符串总结表

[cols="5*", ptions="header"]
|====
|名称
|语法
|插值
|多行
|转义符

|单引号
|+\'...'+
|icon:check-empty[]
|icon:check-empty[]
|+\+

|三单引号
|+\'''...\'''+
|icon:check-empty[]
|icon:check[]
|+\+

|双引号
|+"..."+
|icon:check[]
|icon:check-empty[]
|+\+

|三双引号
|+"""..."""+
|icon:check[]
|icon:check[]
|+\+

|斜线
|+/.../+
|icon:check[]
|icon:check[]
|+\+

|美元斜线
|+$/.../$+
|icon:check[]
|icon:check[]
|+$+
|====

[[_characters]]
=== 字符

与 Java 不同, Groovy 没有明确的字符字面量.
但是, 你可以通过 3 种不同的方式明确的将 Groovy 字符串转换为字符:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=char,indent=0]
----
<1> 声明变量时明确指定其类型为 +char+.
<2> 使用 +as+ 操作符强制类型转换(type coercion).
<3> 使用 +(char)+ 强制类型转换.

NOTE: 当字符存储在变量中时, 做法(option) [conum,data-value=1]_1_ 比较好(interesting),
而其他两种做法([conum,data-value=2]_2_ 和 [conum,data-value=3]_3_), 在必须传入一个
字符参数以调用方法时比较好.

[[_numbers]]
== 数值

Groovy 支持不同类型的整型字面量(integral literals)和浮点型字面量(decimal literals),
依靠 Java 中通用的(usual) +Number+ 类型.

[[_integral_literals]]
=== 整数

整数类型与 Java 中的一样:

* +byte+
* +char+
* +short+
* +int+
* +long+
* +java.lang.BigInteger+

可以用下面的声明来创建这些整型数字:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=int_decl,indent=0]
----

如果使用 +def+ 关键字来声明可选类型(optional type), 那么整数的类型将会发生变化:
它会采用取值范围包含该整数的类型.

对正数而言:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=wide_int_positive,indent=0]
----

对负数也是一样的:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=wide_int_negative,indent=0]
----

[[_alternative_non_base_10_representations]]
// @TODO Alternative non-base 10 representations 更好的翻译
==== 可选的非十进制表示

[[_binary_literal]]
===== 二进制

在 Java 6 及之前版本, 以及在 Groovy 中, 数字可以以 十进制, 八进制, 十六进制 表示,
在 Java 7 及 Groovy 2 中, 可以附加 +0b+ 前缀来使用二进制:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=binary_literal_example,indent=0]
----

[[_octal_literal]]
===== 八进制

八进制数字是以 ++0++ 为前缀, 之后跟上八进制数字(digits), 这样典型的格式来定义的(specified).

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=octal_literal_example,indent=0]
----

[[_hexadecimal_literal]]
===== 十六进制

十六进制数值是以 ++0x++ 为前缀, 之后跟上十六进制数字, 这样典型的格式来定义的.

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=hexadecimal_literal_example,indent=0]
----

[[_decimal_literals]]
=== 浮点数

浮点数类型与 Java 中的一样:

* +float+
* +double+
* +java.lang.BigDecimal+

可以用下面的声明来创建这些浮点型数字:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=float_decl,indent=0]
----

浮点数可以用指数表示, (格式为)表示指数的 +e+ 或 +E+ 字母, 之后是一个可选的正负号,
和一个代表指数的整数:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=float_exp,indent=0]
----

为了方便(conveniently)浮点数精确计算, Groovy 选择 +java.lang.BigDecimal+ 作为它的
浮点数类型. 此外, +float+ 和 +double+ 都是支持的, 但是需要明确的类型声明, 强制类型转换
或者添加后缀. 尽管 +BigDecimal+ 是浮点数的默认类型, 在接受 +float+ 或者 +double+
为参数的方法或闭包中, 浮点数字面量也是能被接受的.

NOTE: 浮点数不能用二进制, 八进制, 十六进制表示法来表示.

[[_underscore_in_literals]]
=== 下划线

当书写很长的数字时, 很难分辨出数字是怎么组织在一起的,
例如以千的分组(groups of thousands), 字符分组(of words) 等.
通过在数字中添加下划线, 将能更容易的区分这些分组:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=underscore_in_number_example,indent=0]
----

[[_number_type_suffixes]]
=== 数字后缀

通过添加后缀(见下表), 我们可以强制指定一个数字(包括二进制, 八进制, 十六进制)的类型, 后缀大小写均可.

[cols="1,2" options="header"]
|====
|类型
|后缀

|BigInteger
|+G+ 或 +g+

|Long
|+L+ 或 +l+

|Integer
|+I+ 或 +i+

|BigDecimal
|+G+ 或 +g+

|Double
|+D+ 或 +d+

|Float
|+F+ 或 +f+
|====

举例:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=number_type_suffixes_example,indent=0]
----

[[_math_operations]]
=== 数学运算

尽管 <<groovy-operators, 操作符>>在后面才讲到, 但讨论数学运算(math operations)的行为(behavior)
和它们的结果类型也是很重要的(important).

除法和乘方二元运算(binary operations)除外(之后讨论),

* +byte+, +char+, +short+ 和 +int+ 之间二元运算的结果为 +int+.
* +long+ 和 +byte+, +char+, +short+, 以及 +int+ 之间二元运算的结果为 +long+.
* +BigInteger+ 和其它任意整型之间二元运算的结果为 +BigInteger+.
* +float+, +double+ 以及 +BigDecimal+ 之间二元运算的结果为 +double+.
* 两个 +BigDecimal+ 之间二元运算的结果为 +BigDecimal+.

下表对这些规则做了总结:

[cols="10" options="header"]
|====
|
| byte
| char
| short
| int
| long
| BigInteger
| float
| double
| BigDecimal

| *byte*
| int
| int
| int
| int
| long
| BigInteger
| double
| double
| double

| *char*
| 
| int
| int
| int
| long
| BigInteger
| double
| double
| double

| *short*
| 
| 
| int
| int
| long
| BigInteger
| double
| double
| double

| *int*
| 
| 
| 
| int
| long
| BigInteger
| double
| double
| double

| *long*
| 
| 
| 
| 
| long
| BigInteger
| double
| double
| double

| *BigInteger*
| 
| 
| 
| 
| 
| BigInteger
| double
| double
| double

| *float*
| 
| 
| 
| 
| 
| 
| double
| double
| double

| *double*
| 
| 
| 
| 
| 
| 
| 
| double
| double

| *BigDecimal*
| 
| 
| 
| 
| 
| 
| 
| 
| BigDecimal
|====

[NOTE]
感谢 Groovy 的运算符重载, 基本的(usual)算术运算(arithmetic operators)同样能工作于
+BigInteger+ 和 +BigDecimal+, 不像 Java, 对于这些类型上的操作你不得不使用明确的方法调用.

[[integer_division]]
==== 除法

如果操作数中有一个为 +double+ 或者 +float+ 类型, 除法操作 +/+ (除等 +/=+) 的结果为
+double+ 类型, 否则为 +BigDecimal+(即两个操作数是 +short+, +char+, +byte+, +int+,
+long+, +BigInteger+, +BigDecimal+ 的任意组合).


+BigDecimal+ division is performed with the +divide()+ method if the division is exact
(ie. yielding a result that can be represented within the bounds of the same precision and scale),
or using a +MathContext+ with a http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html#precision()[precision] 
of the maximum of the two operands' precision plus an extra precision of 10,
and a http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html#scale()[scale] 
of the maximum of 10 and the maximum of the operands' scale.

[NOTE]
由于 Groovy 没有提供专用的(dedicated)整数除法操作符, 所以 Java 中的整数除法应用
+intdiv()+ 方法代替.

[[power_operator]]
==== 乘方
乘方运算用 +**+ 操作符符来表示, 带有2个参数: 底数(base)和指数(exponent).
乘方运算的结果依赖于其操作数, 和运算的结果(尤其是结果能表示为整数)

Groovy 使用以下的规则来判断乘方元算的结果类型:

* 如果指数是浮点数
** 如果结果能表示为 +Integer+, 则返回 +Integer+
** 否则, 如果结果能表示为 +Long+, 则返回 +Long+
** 否则, 返回 +Double+
* 如果指数是整数
** 如果指数是负数(strictly negative), 则可能返回 +Integer+, +Long+, 或者 +Double+, 取决于结果适合那种类型
** 如果指数是整数或者零
*** 如果底数是 +BigDecimal+, 则返回 +BigDecimal+
*** 如果底数是 +BigInteger+, 则返回 +BigInteger+
*** 如果底数是 +Integer+, 结果能用 +Integer+ 表示则返回 +Integer+, 否则 +BigInteger+
*** 如果底数是 +Long+, 结果能用 +Long+ 表示则返回 +Long+, 否则 +BigInteger+

以下的例子是对这些规则的说明:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=number_power,indent=0]
----

== Booleans

Boolean 是用来表示真值 ++true++ 和 ++false++ 的特殊数据类型. 使用这种数据类型来简单的
标识 真/假 <<_conditional_operators, 条件>>.

Boolean 值可以存储在变量中, 赋值给字段, 就像其他的数据类型:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=variable_store_boolean_value,indent=0]
----

++true++ 和 ++false++ 是仅有的2个原生(primitive) boolean 值.
但是可以用<<_bitwise_and_logical_operators, 逻辑操作符>> 来表示更复杂的逻辑表达式.

此外, Groovy 有 <<_the_groovy_truth, 特殊规则>>(通常称为 _Groovy Truth_)
将一个非 boolean 类型的对象转换为 boolean 值.

== Lists

Groovy uses a comma-separated list of values, surrounded by square brackets, to denote lists.
Groovy lists are plain JDK +java.util.List+, as Groovy doesn't define its own collection classes.
The concrete list implementation used when defining list literals are +java.util.ArrayList+ by default,
unless you decide to specify otherwise, as we shall see later on.

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=list_1,indent=0]
----
<1> We define a list numbers delimited by commas and surrounded by square brackets, and we assign that list into a variable
<2> The list is an instance of Java's +java.util+List+ interface
<3> The size of the list can be queried with the +size()+ method, and shows our list contains 3 elements

In the above example, we used a homogeneous list, but you can also create lists containing values of heterogeneous types:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=list_2,indent=0]
----
<1> Our list here contains a number, a string and a boolean value

We mentioned that by default, list literals are actually instances of +java.util.ArrayList+, 
but it is possible to use a different backing type for our lists, 
thanks to using type coercion with the +as+ operator, or with explicit type declaration for your variables:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=coercion_of_list,indent=0]
----
<1> We use coercion with the +as+ operator to explicitly request a +java.util.LinkedList+ implementation
<2> We can say that the variable holding the list literal is of type +java.util.LinkedList+

You can access elements of the list with the +[]+ subscript operator (both for reading and setting values)
with positive indices or negative indices to access elements from the end of the list, as well as with ranges,
and use the +<<+ leftShift operator to append elements to a list:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=subscript_and_leftshift,indent=0]
----
<1> Access the first element of the list (zeroth-based counting)
<2> Access the last element of the list with a negative index: -1 is the first element from the end of the list
<3> Use an assignment to set a new value for the third element of the list
<4> Use the +<<+ leftShift operator to append an element at the end of the list
<5> Access two elements at once, returning a new list containing those two elements
<6> Use a range to access a range of values from the list, from a start to an end element position

As lists can be heterogeneous in nature, lists can also contain other lists to create multi-dimensional lists:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=multi_dim_list,indent=0]
----
<1> Define a list of list of numbers
<2> Access the second element of the top-most list, and the first element of the inner list

== Arrays

Groovy reuses the list notation for arrays, but to make such literals arrays, 
you need to explicitely define the type of the array through coercion or type declaration.

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=array_1,indent=0]
----
<1> Define an array of strings using explicit variable type declaration
<2> Assert that we created an array of strings
<3> Create an array of ints with the +as+ operator
<4> Assert that we created an array of primitive ints

You can also create multi-dimensional arrays:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=array_2,indent=0]
----
<1> You can define the bounds of a new array
<2> Or declare an array without specifying its bounds

Access to elements of an array follows the same notation as for lists:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=array_3,indent=0]
----
<1> Retrieve the first element of the array
<2> Set the value of the third element of the array to a new value

[NOTE]
Java's array initializer notation is not supported by Groovy, 
as the curly braces can be misinterpreted with the notation of Groovy closures.

== Maps

Sometimes called dictionaries or associative arrays in other languages, Groovy features maps.
Maps associate keys to values, separating keys and values with colons, and each key/value pairs with commas, 
and the whole keys and values surrounded by square brackets.

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=map_def_access,indent=0]
----
<1> We define a map of string color names, associated with their hexadecimal-coded html colors
<2> We use the subscript notation to check the content associated with the +red+ key
<3> We can also use the property notation to assert the color green's hexadecimal representation
<4> Similarily, we can use the subscript notation to add a new key/value pair
<5> Or the property notation, to add the +yellow+ color

[NOTE]
When using names for the keys, we actually define string keys in the map.

[NOTE]
Groovy creates maps that are actually instances of +java.util.LinkedHashMap+.

If you try to access a key which is not present in the map:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=unknown_key,indent=0]
----

You will retrieve a +null+ result.

In the examples above, we used string keys, but you can also use values of other types as keys:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=number_key,indent=0]
----

Here, we used numbers as keys, as numbers can unambiguously be recognized as numbers,
so Groovy will not create a string key like in our previous examples.
But consider the case you want to pass a variable in lieu of the key, to have the value of that variable become the key:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=variable_key_1,indent=0]
----
<1> The +key+ associated with the +\'Guillaume'+ name will actually be the +"key"+ string, not the value associated with the +key+ variable
<2> The map doesn't contain the +\'name'+ key
<3> Instead, the map contains a +\'key'+ key

[NOTE]
You can also pass quoted strings as well as keys: +["name": "Guillaume"]+.
This is mandatory if your key string isn't a valid identifier, 
for example if you wanted to create a string key containing a hash like in: +["street-name": "Main street"]+.

When you need to pass variable values as keys in your map definitions, you must surround the variable or expression with parentheses:

[source,groovy]
----
include::{projectdir}/src/spec/test/SyntaxTest.groovy[tags=variable_key_2,indent=0]
----
<1> This time, we surround the +key+ variable with parentheses, to instruct the parser we are passing a variable rather than defining a string key
<2> The map does contain the +name+ key
<3> But the map doesn't contain the +key+ key as before



