<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.0.preview.7">
<title>Design patterns in Groovy</title>
<link rel="stylesheet" href="./assets/css/style.css">
<link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/font-awesome/3.2.1/css/font-awesome.min.css">
<link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="http://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>document.addEventListener('DOMContentLoaded', prettyPrint)</script>
<link rel="stylesheet" href="assets/css/view-example.css">
<script src='assets/js/jquery-2.1.1.min.js'></script>
<script src='assets/js/view-example.js'></script></head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Design patterns in Groovy</h1>
<span id="revnumber">version 2.4.0-SNAPSHOT</span>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_patterns">1. Patterns</a></li>
<li>
<ul class="sectlevel4">
<li><a href="#_abstract_factory_pattern">抽象工厂模式</a></li>
<li>
<ul class="sectlevel5">
<li><a href="#_example">示例</a></li>
</ul>
</li>
<li><a href="#_adapter_pattern">Adapter Pattern</a></li>
<li>
<ul class="sectlevel5">
<li><a href="#_delegation_example">Delegation Example</a></li>
<li><a href="#_inheritance_example">Inheritance Example</a></li>
<li><a href="#_adapting_using_closures">Adapting using Closures</a></li>
<li><a href="#_adapting_using_the_expandometaclass">Adapting using the ExpandoMetaClass</a></li>
</ul>
</li>
<li><a href="#_bouncer_pattern">Bouncer Pattern</a></li>
<li>
<ul class="sectlevel5">
<li><a href="#_null_checking_example">Null Checking Example</a></li>
<li><a href="#_validation_example">Validation Example</a></li>
</ul>
</li>
<li><a href="#_chain_of_responsibility_pattern">Chain of Responsibility Pattern</a></li>
<li>
<ul class="sectlevel5">
<li><a href="#_example_2">Example</a></li>
</ul>
</li>
<li><a href="#_composite_pattern">Composite Pattern</a></li>
<li>
<ul class="sectlevel5">
<li><a href="#_example_3">Example</a></li>
</ul>
</li>
<li><a href="#_decorator_pattern">Decorator Pattern</a></li>
<li>
<ul class="sectlevel5">
<li><a href="#_traditional_example">Traditional Example</a></li>
<li><a href="#_a_touch_of_dynamic_behaviour">A touch of dynamic behaviour</a></li>
<li><a href="#_runtime_behaviour_embellishment">Runtime behaviour embellishment</a></li>
<li><a href="#_more_dynamic_decorating">More dynamic decorating</a></li>
<li><a href="#_decorating_with_an_interceptor">Decorating with an Interceptor</a></li>
<li><a href="#_decorating_with_java_lang_reflect_proxy">Decorating with java.lang.reflect.Proxy</a></li>
<li><a href="#_decorating_with_spring">Decorating with Spring</a></li>
<li><a href="#_asynchronous_decorators_using_gpars">Asynchronous Decorators using GPars</a></li>
</ul>
</li>
<li><a href="#_delegation_pattern">Delegation Pattern</a></li>
<li>
<ul class="sectlevel5">
<li><a href="#_implement_delegation_pattern_using_expandometaclass">Implement Delegation Pattern using ExpandoMetaClass</a></li>
<li><a href="#_implement_delegation_pattern_using_delegate_annotation">Implement Delegation Pattern using @Delegate annotation</a></li>
</ul>
</li>
<li><a href="#_flyweight_pattern">Flyweight Pattern</a></li>
<li>
<ul class="sectlevel5">
<li><a href="#_example_4">Example</a></li>
</ul>
</li>
<li><a href="#_iterator_pattern">Iterator Pattern</a></li>
<li><a href="#_loan_my_resource_pattern">Loan my Resource Pattern</a></li>
<li>
<ul class="sectlevel5">
<li><a href="#_example_5">Example</a></li>
</ul>
</li>
<li><a href="#_null_object_pattern">Null Object Pattern</a></li>
<li>
<ul class="sectlevel5">
<li><a href="#_simple_example">Simple Example</a></li>
<li><a href="#_tree_example">Tree Example</a></li>
</ul>
</li>
<li><a href="#_pimp_my_library_pattern">Pimp my Library Pattern</a></li>
<li>
<ul class="sectlevel5">
<li><a href="#_example_6">Example</a></li>
</ul>
</li>
<li><a href="#_proxy_pattern">Proxy Pattern</a></li>
<li>
<ul class="sectlevel5">
<li><a href="#_example_7">Example</a></li>
</ul>
</li>
<li><a href="#_singleton_pattern">Singleton Pattern</a></li>
<li>
<ul class="sectlevel5">
<li><a href="#_example_the_classic_java_singleton">Example: The Classic Java Singleton</a></li>
<li><a href="#_example_singleton_via_metaprogramming">Example: Singleton via MetaProgramming</a></li>
<li><a href="#_guice_example">Guice Example</a></li>
<li><a href="#_spring_example">Spring Example</a></li>
<li><a href="#_further_information">Further information</a></li>
</ul>
</li>
<li><a href="#_state_pattern">State Pattern</a></li>
<li>
<ul class="sectlevel5">
<li><a href="#_example_8">Example</a></li>
<li><a href="#_variation_1_leveraging_interface_oriented_design">Variation 1: Leveraging Interface-Oriented Design</a></li>
<li><a href="#_variation_2_extract_state_pattern_logic">Variation 2: Extract State Pattern Logic</a></li>
<li><a href="#_variation_3_bring_on_the_dsl">Variation 3: Bring on the DSL</a></li>
</ul>
</li>
<li><a href="#_strategy_pattern">Strategy Pattern</a></li>
<li>
<ul class="sectlevel5">
<li><a href="#_example_9">Example</a></li>
</ul>
</li>
<li><a href="#_template_method_pattern">Template Method Pattern</a></li>
<li>
<ul class="sectlevel5">
<li><a href="#_example_10">Example</a></li>
</ul>
</li>
<li><a href="#_visitor_pattern">Visitor Pattern</a></li>
<li>
<ul class="sectlevel5">
<li><a href="#_simple_example_2">Simple Example</a></li>
<li><a href="#_advanced_example">Advanced Example</a></li>
<li>
<ul class="sectlevel6">
<li><a href="#_why_to_use_this">Why to use this</a></li>
<li><a href="#_what_happens_if_we_add_a_new_type">What happens if we add a new type?</a></li>
<li><a href="#_what_if_we_want_to_have_different_iteration_patterns">What if we want to have different iteration patterns?</a></li>
<li><a href="#_make_it_groovy">Make it Groovy</a></li>
<li><a href="#_summary">Summary</a></li>
</ul>
</li>
<li><a href="#_further_information_2">Further Information</a></li>
</ul>
</li>
<li><a href="#_references">1.19. References</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Using <a href="http://en.wikipedia.org/wiki/Design_pattern_%28computer_science%29">design patterns</a> with Java is a well-established topic. Design patterns also apply to Groovy:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>some patterns carry over directly (and can make use of normal Groovy syntax improvements for greater readability)</p>
</li>
<li>
<p>some patterns are no longer required because they are built right into the language or because Groovy supports a better way of achieving the intent of the pattern</p>
</li>
<li>
<p>some patterns that have to be expressed at the design level in other languages can be implemented directly in Groovy (due to the way Groovy can blur the distinction between design and implementation)</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_patterns">1. Patterns</h2>
<div class="sectionbody">
<div class="sect4">
<h5 id="_abstract_factory_pattern">抽象工厂模式</h5>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Abstract_factory_pattern">抽象工厂模式</a>提供了一种对拥有
共同产品族的不同工厂进行封装的一种方法. 它体现了一个标准工厂的意图, 即不需要使用代码去确定具体的接口,
也不需要了解隐藏的接口后的实现, 而是适用于一组接口,并使用实现了这些接口的某个系列的实现类作为其实现.</p>
</div>
<div class="paragraph">
<p>举个例子, 我可能有Button, TextField 和 Scrollbar这三个接口. 我可能会用WindowsButton,
MacButton, FlashButton作为Button的实现类. 我可能会用WindowsScrollBar, MacScrollBar
及 FlashScrollBar作为ScrollBar的实现类. 通过使用抽象工厂模式, 使我能一次选择一个窗口系统
(如 Windows, Mac, Flash), 然后每次写到相关的代码时总是引用到这个接口,
而且这个接口的实现类总是和窗口系统相适应(即所有的控件都来自同一个窗口系统).</p>
</div>
<div class="sect5">
<h6 id="_example">示例</h6>
<div class="paragraph">
<p>假设我们希望写个游戏系统. 我们可能会注意到很多游戏都拥有相似的功能和控制.</p>
</div>
<div class="paragraph">
<p>我们决定将这些游戏共有的代码和每个游戏特有的代码分配到不同的类中.</p>
</div>
<div class="paragraph">
<p>首先,我们看一看http://en.wikipedia.org/wiki/Two-Up[Two-up]游戏特有的代码.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class TwoupMessages {
    def welcome = 'Welcome to the twoup game, you start with $1000'
    def done = 'Sorry, you have no money left, goodbye'
}

class TwoupInputConverter {
    def convert(input) { input.toInteger() }
}

class TwoupControl {
    private money = 1000
    private random = new Random()
    private tossWasHead() {
        def next = random.nextInt()
        return next % 2 == 0
    }
    def moreTurns() {
        if (money &gt; 0) {
            println "You have $money, how much would you like to bet?"
            return true
        }

        false
    }
    def play(amount) {
        def coin1 = tossWasHead()
        def coin2 = tossWasHead()
        if (coin1 &amp;&amp; coin2) {
            money += amount
            println 'You win'
        } else if (!coin1 &amp;&amp; !coin2) {
            money -= amount
            println 'You lose'
        } else {
            println 'Draw'
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在,我们看一下猜数字游戏所特有的代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class GuessGameMessages {
    def welcome = 'Welcome to the guessing game, my secret number is between 1 and 100'
    def done = 'Correct'
}

class GuessGameInputConverter {
    def convert(input) { input.toInteger() }
}

class GuessGameControl {
    private lower = 1
    private upper = 100
    private guess = new Random().nextInt(upper - lower) + lower
    def moreTurns() {
        def done = (lower == guess || upper == guess)
        if (!done) {
            println "Enter a number between $lower and $upper"
        }

        !done
    }
    def play(nextGuess) {
        if (nextGuess &lt;= guess) {
            lower = [lower, nextGuess].max()
        }
        if (nextGuess &gt;= guess) {
            upper = [upper, nextGuess].min()
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在,写我们的工厂代码(factory code):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">def guessFactory = [messages: GuessGameMessages, control: GuessGameControl, converter: GuessGameInputConverter]
def twoupFactory = [messages: TwoupMessages, control: TwoupControl, converter: TwoupInputConverter]

class GameFactory {
    def static factory
    def static getMessages() { return factory.messages.newInstance() }
    def static getControl() { return factory.control.newInstance() }
    def static getConverter() { return factory.converter.newInstance() }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>抽象工厂模式中最重要的部分就是允许选择一类族(an entire family of concrete classes)作为
这些工厂的实现类.</p>
</div>
<div class="paragraph">
<p>抽象工厂模式是这样使用的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">GameFactory.factory = twoupFactory
def messages = GameFactory.messages
def control = GameFactory.control
def converter = GameFactory.converter
println messages.welcome
def reader = new BufferedReader(new InputStreamReader(System.in))
while (control.moreTurns()) {
    def input = reader.readLine().trim()
    control.play(converter.convert(input))
}
println messages.done</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意第一行配置了我们将会使用哪一类族(family)的游戏实现类.
我们通过第一行代码展示的工厂属性,选择具体使用哪一类族这一过程并不重要.
我们可以使用另一种等价的方式使用这种模式,比如,我们可以询问用户想玩哪一种游戏,
或者使用环境设置来觉得进行哪总游戏等等.</p>
</div>
<div class="paragraph">
<p>按照我们的代码,游戏运行起来会像这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Welcome to the twoup game, you start with $1000
You have 1000, how much would you like to bet?
300
Draw
You have 1000, how much would you like to bet?
700
You win
You have 1700, how much would you like to bet?
1700
You lose
Sorry, you have no money left, goodbye</pre>
</div>
</div>
<div class="paragraph">
<p>如果我们将脚本(script)的第一行改为 <code>GameFactory.factory = guessFactory</code>,
那么示例程序运行起来会是这个样子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Welcome to the guessing game, my secret number is between 1 and 100
Enter a number between 1 and 100
75
Enter a number between 1 and 75
35
Enter a number between 1 and 35
15
Enter a number between 1 and 15
5
Enter a number between 5 and 15
10
Correct</pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_adapter_pattern">Adapter Pattern</h5>
<div class="paragraph">
<p>The <a href="http://en.wikipedia.org/wiki/Adapter_pattern">Adapter Pattern</a> (sometimes called the wrapper pattern) allows objects satisfying one interface to be used where another type of interface is expected. There are two typical flavours of the pattern: the <em>delegation</em> flavour and the <em>inheritance</em> flavour.</p>
</div>
<div class="sect5">
<h6 id="_delegation_example">Delegation Example</h6>
<div class="paragraph">
<p>Suppose we have the following classes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class SquarePeg {
    def width
}

class RoundPeg {
    def radius
}

class RoundHole {
    def radius
    def pegFits(peg) {
        peg.radius &lt;= radius
    }
    String toString() { "RoundHole with radius $radius" }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can ask the <code>RoundHole</code> class if a <code>RoundPeg</code> fits in it, but if we ask the same question for a <code>SquarePeg</code>, then it will fail because the <code>SquarePeg</code> class doesn&#8217;t have a <code>radius</code> property (i.e. doesn&#8217;t satisfy the required interface).</p>
</div>
<div class="paragraph">
<p>To get around this problem, we can create an adapter to make it appear to have the correct interface. It would look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class SquarePegAdapter {
    def peg
    def getRadius() {
        Math.sqrt(((peg.width / 2) ** 2) * 2)
    }
    String toString() {
        "SquarePegAdapter with peg width $peg.width (and notional radius $radius)"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can use the adapter like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">def hole = new RoundHole(radius: 4.0)
(4..7).each { w -&gt;
    def peg = new SquarePegAdapter(peg: new SquarePeg(width: w))
    if (hole.pegFits(peg)) {
        println "peg $peg fits in hole $hole"
    } else {
        println "peg $peg does not fit in hole $hole"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which results in the following output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>peg SquarePegAdapter with peg width 4 (and notional radius 2.8284271247461903) fits in hole RoundHole with radius 4.0
peg SquarePegAdapter with peg width 5 (and notional radius 3.5355339059327378) fits in hole RoundHole with radius 4.0
peg SquarePegAdapter with peg width 6 (and notional radius 4.242640687119285) does not fit in hole RoundHole with radius 4.0
peg SquarePegAdapter with peg width 7 (and notional radius 4.949747468305833) does not fit in hole RoundHole with radius 4.0</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_inheritance_example">Inheritance Example</h6>
<div class="paragraph">
<p>Let&#8217;s consider the same example again using inheritance. First, here are the original classes (unchanged):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class SquarePeg {
    def width
}

class RoundPeg {
    def radius
}

class RoundHole {
    def radius
    def pegFits(peg) {
        peg.radius &lt;= radius
    }
    String toString() { "RoundHole with radius $radius" }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>An adapter using inheritance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class SquarePegAdapter extends SquarePeg {
    def getRadius() {
        Math.sqrt(((width / 2) ** 2) * 2)
    }
    String toString() {
        "SquarePegAdapter with width $width (and notional radius $radius)"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using the adapter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">def hole = new RoundHole(radius: 4.0)
(4..7).each { w -&gt;
    def peg = new SquarePegAdapter(peg: new SquarePeg(width: w))
    if (hole.pegFits(peg)) {
        println "peg $peg fits in hole $hole"
    } else {
        println "peg $peg does not fit in hole $hole"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>peg SquarePegAdapter with width 4 (and notional radius 2.8284271247461903) fits in hole RoundHole with radius 4.0
peg SquarePegAdapter with width 5 (and notional radius 3.5355339059327378) fits in hole RoundHole with radius 4.0
peg SquarePegAdapter with width 6 (and notional radius 4.242640687119285) does not fit in hole RoundHole with radius 4.0
peg SquarePegAdapter with width 7 (and notional radius 4.949747468305833) does not fit in hole RoundHole with radius 4.0</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_adapting_using_closures">Adapting using Closures</h6>
<div class="paragraph">
<p>As a variation of the previous examples, we could instead define the following interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">interface RoundThing {
    def getRadius()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can then define an adapter as a closure as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">def adapter = {
    p -&gt; [getRadius: { Math.sqrt(((p.width / 2) ** 2) * 2) }] as RoundThing
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And use it like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">def peg = new SquarePeg(width: 4)
if (hole.pegFits(adapter(peg))) {
    // ... as before
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_adapting_using_the_expandometaclass">Adapting using the ExpandoMetaClass</h6>
<div class="paragraph">
<p>As of Groovy 1.1, there is a built-in MetaClass which can automatically add properties and methods dynamically.</p>
</div>
<div class="paragraph">
<p>Here is how the example would work using that feature:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">def peg = new SquarePeg(width: 4)
peg.metaClass.radius = Math.sqrt(((peg.width / 2) ** 2) * 2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>After you create a peg object, you can simply add a property to it on the fly. No need to change the original class and no need for an adapter class.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_bouncer_pattern">Bouncer Pattern</h5>
<div class="paragraph">
<p>The <a href="http://www.c2.com/cgi/wiki?BouncerPattern">Bouncer Pattern</a> describes usage of a method whose sole purpose is to either throw an exception (when particular conditions hold) or do nothing. Such methods are often used to defensively guard pre-conditions of a method.</p>
</div>
<div class="paragraph">
<p>When writing utility methods, you should always guard against faulty input arguments. When writing internal methods, you may be able to ensure that certain pre-conditions always hold by having sufficient unit tests in place. Under such circumstances, you may reduce the desirability to have guards on your methods.</p>
</div>
<div class="paragraph">
<p>Groovy differs from other languages in that you frequently use the <code>assert</code> method within your methods rather than having a large number of utility checker methods or classes.</p>
</div>
<div class="sect5">
<h6 id="_null_checking_example">Null Checking Example</h6>
<div class="paragraph">
<p>We might have a utility method such as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class NullChecker {
    static check(name, arg) {
        if (arg == null) {
            throw new IllegalArgumentException(name + ' is null')
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And we would use it like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">void doStuff(String name, Object value) {
    NullChecker.check('name', name)
    NullChecker.check('value', value)
    // do stuff
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>But a more Groovy way to do this would simply be like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">void doStuff(String name, Object value) {
    assert name != null, 'name should not be null'
    assert value != null, 'value should not be null'
    // do stuff
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_validation_example">Validation Example</h6>
<div class="paragraph">
<p>As an alternative example, we might have this utility method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class NumberChecker {
    static final String NUMBER_PATTERN = "\\\\d+(\\\\.\\\\d+(E-?\\\\d+)?)?"
    static isNumber(str) {
        if (!str ==~ NUMBER_PATTERN) {
            throw new IllegalArgumentException("Argument '$str' must be a number")
        }
    }
    static isNotZero(number) {
        if (number == 0) {
            throw new IllegalArgumentException('Argument must not be 0')
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And we would use it like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">def stringDivide(String dividendStr, String divisorStr) {
    NumberChecker.isNumber(dividendStr)
    NumberChecker.isNumber(divisorStr)
    def dividend = dividendStr.toDouble()
    def divisor = divisorStr.toDouble()
    NumberChecker.isNotZero(divisor)
    dividend / divisor
}

println stringDivide('1.2E2', '3.0')
// =&gt; 40.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>But with Groovy we could just as easily use:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">def stringDivide(String dividendStr, String divisorStr) {
    assert dividendStr =~ NumberChecker.NUMBER_PATTERN
    assert divisorStr =~ NumberChecker.NUMBER_PATTERN
    def dividend = dividendStr.toDouble()
    def divisor = divisorStr.toDouble()
    assert divisor != 0, 'Divisor must not be 0'
    dividend / divisor
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_chain_of_responsibility_pattern">Chain of Responsibility Pattern</h5>
<div class="paragraph">
<p>In the Chain of Responsibility Pattern, objects using and implementing an interface (one or more methods) are intentionally loosely coupled. A set of objects that <em>implement</em> the interface are organised in a list (or in rare cases a tree). Objects using the interface make requests from the first <em>implementor</em> object. It will decide whether to perform any action itself and whether to pass the request further down the line in the list (or tree). Sometimes a default implementation for some request is also coded into the pattern if none of the implementors respond to the request.</p>
</div>
<div class="sect5">
<h6 id="_example_2">Example</h6>
<div class="paragraph">
<p>In this example, the script sends requests to the <code>lister</code> object. The <code>lister</code> points to a <code>UnixLister</code> object. If it can&#8217;t handle the request, it sends the request to the <code>WindowsLister</code>. If it can&#8217;t handle the request, it sends the request to the <code>DefaultLister</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class UnixLister {
    private nextInLine
    UnixLister(next) { nextInLine = next }
    def listFiles(dir) {
        if (System.getProperty('os.name') == 'Linux') {
            println "ls $dir".execute().text
        } else {
            nextInLine.listFiles(dir)
        }
    }
}

class WindowsLister {
    private nextInLine
    WindowsLister(next) { nextInLine = next }
    def listFiles(dir) {
        if (System.getProperty('os.name') == 'Windows XP') {
            println "cmd.exe /c dir $dir".execute().text
        } else {
            nextInLine.listFiles(dir)
        }
    }
}

class DefaultLister {
    def listFiles(dir) {
        new File(dir).eachFile { f -&gt; println f }
    }
}

def lister = new UnixLister(new WindowsLister(new DefaultLister()))

lister.listFiles('Downloads')</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output will be a list of files (with slightly different format depending on the operating system).</p>
</div>
<div class="paragraph">
<p>Here is a UML representation:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="assets/img/ChainOfResponsibilityClasses.gif" alt="ChainOfResponsibilityClasses">
</div>
</div>
<div class="paragraph">
<p>Variations to this pattern:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>we could have an explicit interface, e.g. <code>Lister</code>, to statically type the implementations but because of <em>duck-typing</em> this is optional</p>
</li>
<li>
<p>we could use a chain tree instead of a list, e.g. <code>if (animal.hasBackbone())</code> delegate to <code>VertebrateHandler</code> else delegate to <code>InvertebrateHandler</code></p>
</li>
<li>
<p>we could always pass down the chain even if we processed a request</p>
</li>
<li>
<p>we could decide at some point to not respond and not pass down the chain</p>
</li>
<li>
<p>we could use Groovy’s meta-programming capabilities to pass unknown methods down the chain</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_composite_pattern">Composite Pattern</h5>
<div class="paragraph">
<p>The <a href="http://en.wikipedia.org/wiki/Composite_pattern">Composite Pattern</a> allows you to treat single instances of an object the same way as a group of objects. The pattern is often used with hierarchies of objects. Typically, one or more methods should be callable in the same way for either <em>leaf</em> or <em>composite</em> nodes within the hierarchy. In such a case, composite nodes typically invoke the same named method for each of their children nodes.</p>
</div>
<div class="sect5">
<h6 id="_example_3">Example</h6>
<div class="paragraph">
<p>Consider this usage of the composite pattern where we want to call <code>toString()</code> on either <code>Leaf</code> or <code>Composite</code> objects.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="assets/img/CompositeClasses.gif" alt="CompositeClasses">
</div>
</div>
<div class="paragraph">
<p>In Java, the <code>Component</code> class is essential as it provides the type used for both leaf and composite nodes. In Groovy, because of duck-typing, we don&#8217;t need it for that purpose, however, it can still server as a useful place to place common behaviour between the leaf and composite nodes.</p>
</div>
<div class="paragraph">
<p>For our purposes, we will assemble the following hierarchy of components.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="assets/img/CompositeComponents.gif" alt="CompositeComponents">
</div>
</div>
<div class="paragraph">
<p>Here is the code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">abstract class Component {
    def name
    def toString(indent) {
        ("-" * indent) + name
    }
}

class Composite extends Component {
    private children = []
    def toString(indent) {
        def s = super.toString(indent)
        children.each { child -&gt;
            s += "\\n" + child.toString(indent + 1)
        }
        s
    }
    def leftShift(component) {
        children &lt;&lt; component
    }
}

class Leaf extends Component { }

def root = new Composite(name: "root")
root &lt;&lt; new Leaf(name: "leaf A")
def comp = new Composite(name: "comp B")
root &lt;&lt; comp
root &lt;&lt; new Leaf(name: "leaf C")
comp &lt;&lt; new Leaf(name: "leaf B1")
comp &lt;&lt; new Leaf(name: "leaf B2")
println root.toString(0)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is the resulting output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>root
-leaf A
-comp B
--leaf B1
--leaf B2
-leaf C</pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_decorator_pattern">Decorator Pattern</h5>
<div class="paragraph">
<p>The <a href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator Pattern</a> provides a mechanism to embellish the behaviour of an object without changing its essential interface. A decorated object should be able to be substituted wherever the original (non-decorated) object was expected. Decoration typically does not involve modifying the source code of the original object and decorators should be able to be combined in flexible ways to produce objects with several embellishments.</p>
</div>
<div class="sect5">
<h6 id="_traditional_example">Traditional Example</h6>
<div class="paragraph">
<p>Suppose we have the following <code>Logger</code> class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class Logger {
    def log(String message) {
        println message
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There might be times when it is useful to timestamp a log message, or times when we might want to change the case of the message. We could try to build all of this functionality into our <code>Logger</code> class. If we did that, the <code>Logger</code> class would start to be very complex. Also, everyone would obtain all of features even when they might not want a small subset of the features. Finally, feature interaction would become quite difficult to control.</p>
</div>
<div class="paragraph">
<p>To overcome these drawbacks, we instead define two decorator classes. Uses of the <code>Logger</code> class are free to embellish their base logger with zero or more decorator classes in whatever order they desire. The classes look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class TimeStampingLogger extends Logger {
    private Logger logger
    TimeStampingLogger(logger) {
        this.logger = logger
    }
    def log(String message) {
        def now = Calendar.instance
        logger.log("$now.time: $message")
    }
}

class UpperLogger extends Logger {
    private Logger logger
    UpperLogger(logger) {
        this.logger = logger
    }
    def log(String message) {
        logger.log(message.toUpperCase())
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can use the decorators like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">def logger = new UpperLogger(new TimeStampingLogger(new Logger()))
logger.log("G'day Mate")
// =&gt; Tue May 22 07:13:50 EST 2007: G'DAY MATE</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can see that we embellish the logger behaviour with both decorators. Because of the order we chose to apply the decorators, our log message comes out capitalised and the timestamp is in normal case. If we swap the order around, let&#8217;s see what happens:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">logger = new TimeStampingLogger(new UpperLogger(new Logger()))
logger.log('Hi There')
// =&gt; TUE MAY 22 07:13:50 EST 2007: HI THERE</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now the timestamp itself has also been changed to be uppercase.</p>
</div>
</div>
<div class="sect5">
<h6 id="_a_touch_of_dynamic_behaviour">A touch of dynamic behaviour</h6>
<div class="paragraph">
<p>Our previous decorators were specific to <code>Logger</code> objects. We can use Groovy&#8217;s Meta-Object Programming capabilities to create a decorator which is far more general purpose in nature. Consider this class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class GenericLowerDecorator {
    private delegate
    GenericLowerDecorator(delegate) {
        this.delegate = delegate
    }
    def invokeMethod(String name, args) {
        def newargs = args.collect { arg -&gt;
            if (arg instanceof String) {
                return arg.toLowerCase()
            } else {
                return arg
            }
        }
        delegate.invokeMethod(name, newargs)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It takes any class and decorates it so that any <code>String</code> method parameter will automatically be changed to lower case.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">logger = new GenericLowerDecorator(new TimeStampingLogger(new Logger()))
logger.log('IMPORTANT Message')
// =&gt; Tue May 22 07:27:18 EST 2007: important message</code></pre>
</div>
</div>
<div class="paragraph">
<p>Just be careful with ordering here. The original decorators were restricted to decorating <code>Logger</code> objects. This decorator work with any object type, so we can&#8217;t swap the ordering around, i.e. this won&#8217;t work:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>// Can't mix and match Interface-Oriented and Generic decorators
// logger = new TimeStampingLogger(new GenericLowerDecorator(new Logger()))</pre>
</div>
</div>
<div class="paragraph">
<p>We could overcome this limitation be generating an appropriate Proxy type at runtime but we won&#8217;t complicate the example here.</p>
</div>
</div>
<div class="sect5">
<h6 id="_runtime_behaviour_embellishment">Runtime behaviour embellishment</h6>
<div class="paragraph">
<p>You can also consider using the <code>ExpandoMetaClass</code> from Groovy 1.1 to dynamically embellish a class with behaviour. This isn&#8217;t the normal style of usage of the decorator pattern (it certainly isn&#8217;t nearly as flexible) but may help you to achieve similar results in some cases without creating a new class.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s what the code looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">// current mechanism to enable ExpandoMetaClass
GroovySystem.metaClassRegistry.metaClassCreationHandle = new ExpandoMetaClassCreationHandle()

def logger = new Logger()
logger.metaClass.log = { String m -&gt; println 'message: ' + m.toUpperCase() }
logger.log('x')
// =&gt; message: X</code></pre>
</div>
</div>
<div class="paragraph">
<p>This achieves a similar result to applying a single decorator but we have no way to easily apply and remove embellishments on the fly.</p>
</div>
</div>
<div class="sect5">
<h6 id="_more_dynamic_decorating">More dynamic decorating</h6>
<div class="paragraph">
<p>Suppose we have a calculator class (Actually any class would do).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class Calc {
    def add(a, b) { a + b }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We might be interested in observing usage of the class over time. If it is buried deep within our codebase, it might be hard to determine when it is being called and with what parameters. Also, it might be hard to know if it is performing well. We can easily make a generic tracing decorator that prints out tracing information whenever any method on the <code>Calc</code> class is called and also provide timing information about how long it took to execute. Here is the code for the tracing decorator:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class TracingDecorator {
    private delegate
    TracingDecorator(delegate) {
        this.delegate = delegate
    }
    def invokeMethod(String name, args) {
        println "Calling $name$args"
        def before = System.currentTimeMillis()
        def result = delegate.invokeMethod(name, args)
        println "Got $result in ${System.currentTimeMillis()-before} ms"
        result
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is how to use the class in a script:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">def tracedCalc = new TracingDecorator(new Calc())
assert 15 == tracedCalc.add(3, 12)</code></pre>
</div>
</div>
<div class="paragraph">
<p>And here is what you would see after running this script:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Calling add{3, 12}
Got 15 in 31 ms</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_decorating_with_an_interceptor">Decorating with an Interceptor</h6>
<div class="paragraph">
<p>The above timing example hooks into the lifecycle of Groovy objects (via <code>invokeMethod</code>). This is such an important style performing meta-programming that Groovy has special support for this style of decorating using <em>interceptors</em>.</p>
</div>
<div class="paragraph">
<p>Groovy even comes with a built-in <code>TracingInterceptor</code>. We can extend the built-in class like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class TimingInterceptor extends TracingInterceptor {
    private beforeTime
    def beforeInvoke(object, String methodName, Object[] arguments) {
        super.beforeInvoke(object, methodName, arguments)
        beforeTime = System.currentTimeMillis()
    }
    Object afterInvoke(Object object, String methodName, Object[] arguments, Object result) {
        super.afterInvoke(object, methodName, arguments, result)
        def duration = System.currentTimeMillis() - beforeTime
        writer.write("Duration: $duration ms\\n")
        writer.flush()
        result
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is an example of using this new class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">def proxy = ProxyMetaClass.getInstance(Calc)
proxy.interceptor = new TimingInterceptor()
proxy.use {
    assert 7 == new Calc().add(1, 6)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And here is the output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>before Calc.ctor()
after  Calc.ctor()
Duration: 0 ms
before Calc.add(java.lang.Integer, java.lang.Integer)
after  Calc.add(java.lang.Integer, java.lang.Integer)
Duration: 2 ms</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_decorating_with_java_lang_reflect_proxy">Decorating with java.lang.reflect.Proxy</h6>
<div class="paragraph">
<p>If you are trying to decorate an object (i.e. just a particular instance of the class, not the class generally), then you can use Java&#8217;s <code>java.lang.reflect.Proxy</code>. Groovy makes working with this easier than just Java. Below is a code sample taken out of a grails project that wraps a <code>java.sql.Connection</code> so that it&#8217;s close method is a no-op:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">protected Sql getGroovySql() {
    final Connection con = session.connection()
    def invoker = { object, method, args -&gt;
        if (method.name == "close") {
            log.debug("ignoring call to Connection.close() for use by groovy.sql.Sql")
        } else {
            log.trace("delegating $method")
            return con.invokeMethod(method.name, args)
        }
    } as InvocationHandler;
    def proxy = Proxy.newProxyInstance( getClass().getClassLoader(), [Connection] as Class[], invoker )
    return new Sql(proxy)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If there were many methods to intercept, then this approach could be modified to look up closure in a map by method name and invoke it.</p>
</div>
</div>
<div class="sect5">
<h6 id="_decorating_with_spring">Decorating with Spring</h6>
<div class="paragraph">
<p>The <a href="http://www.springframework.org">Spring Framework</a> allows decorators to be applied with <em>interceptors</em> (you may have heard the terms <em>advice</em> or <em>aspect</em>). You can leverage this mechanism from Groovy as well.</p>
</div>
<div class="paragraph">
<p>First define a class that you want to decorate (we&#8217;ll also use an interface as is normal Spring practice):</p>
</div>
<div class="paragraph">
<p>Here&#8217;s the interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">interface Calc {
    def add(a, b)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here&#8217;s the class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class CalcImpl implements Calc {
    def add(a, b) { a + b }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, we define our wiring in a file called <code>beans.xml</code> as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="xml language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:lang="http://www.springframework.org/schema/lang"
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang.xsd"&gt;

    &lt;bean id="performanceInterceptor" autowire="no"
          class="org.springframework.aop.interceptor.PerformanceMonitorInterceptor"&gt;
        &lt;property name="loggerName" value="performance"/&gt;
    &lt;/bean&gt;
    &lt;bean id="calc" class="util.CalcImpl"/&gt;
    &lt;bean class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"&gt;
        &lt;property name="beanNames" value="calc"/&gt;
        &lt;property name="interceptorNames" value="performanceInterceptor"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, our script looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">@Grab('org.springframework:spring-context:3.2.2.RELEASE')
import org.springframework.context.support.ClassPathXmlApplicationContext

def ctx = new ClassPathXmlApplicationContext('beans.xml')
def calc = ctx.getBean('calc')
println calc.add(3, 25)</code></pre>
</div>
</div>
<div class="paragraph">
<p>And when we run it, we see the results:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>21/05/2007 23:02:35 org.springframework.aop.interceptor.PerformanceMonitorInterceptor invokeUnderTrace
FINEST: StopWatch 'util.Calc.add': running time (millis) = 16</pre>
</div>
</div>
<div class="paragraph">
<p>You may have to adjust your <code>logging.properties</code> file for messages at log level <code>FINEST</code> to be displayed.</p>
</div>
</div>
<div class="sect5">
<h6 id="_asynchronous_decorators_using_gpars">Asynchronous Decorators using GPars</h6>
<div class="paragraph">
<p>Using the example code in <a href="http://www.cs.iastate.edu/~design/projects/panini/docs/starting.shtml">Panini</a> for inspiration. Here is a Groovy version that avoids using an <code>@AddedBehavior</code> annotation at the expense of not having as general an algorithm for selecting the methods to decorate. This isn&#8217;t a limitation of the particular approach chosen but just a simplification for illustrative purposes (but don&#8217;t assume below is an exact equivalent).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">@Grab('org.codehaus.gpars:gpars:0.10')
import static groovyx.gpars.GParsPool.withPool

interface Document {
    void print()
    String getText()
}

class DocumentImpl implements Document {
    def document
    void print() { println document }
    String getText() { document }
}

def words(String text) {
    text.replaceAll('[^a-zA-Z]', ' ').trim().split("\\\\s+")*.toLowerCase()
}

def avgWordLength = {
    def words = words(it.text)
    sprintf "Avg Word Length: %4.2f", words*.size().sum() / words.size()
}
def modeWord = {
    def wordGroups = words(it.text).groupBy {it}.collectEntries { k, v -&gt; [k, v.size()] }
    def maxSize = wordGroups*.value.max()
    def maxWords = wordGroups.findAll { it.value == maxSize }
    "Mode Word(s): ${maxWords*.key.join(', ')} ($maxSize occurrences)"
}
def wordCount = { d -&gt; "Word Count: " + words(d.text).size() }

def asyncDecorator(Document d, Closure c) {
    ProxyGenerator.INSTANCE.instantiateDelegate([print: {
        withPool {
            def result = c.callAsync(d)
            d.print()
            println result.get()
        }
    }], [Document], d)
}

Document d = asyncDecorator(asyncDecorator(asyncDecorator(
        new DocumentImpl(document:"This is the file with the words in it\\n\\t\\nDo you see the words?\\n"),
//        new DocumentImpl(document: new File('AsyncDecorator.groovy').text),
        wordCount), modeWord), avgWordLength)
d.print()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_delegation_pattern">Delegation Pattern</h5>
<div class="paragraph">
<p>The <a href="http://en.wikipedia.org/wiki/Delegation_pattern">Delegation Pattern</a> is a technique where an object&#8217;s behavior (public methods) is implemented by delegating responsibility to one or more associated objects.</p>
</div>
<div class="paragraph">
<p>Groovy allows the traditional style of applying the delegation pattern, e.g. see <a href="#_replace_inheritance_with_delegation">Replace Inheritance with Delegation</a>.</p>
</div>
<div class="sect5">
<h6 id="_implement_delegation_pattern_using_expandometaclass">Implement Delegation Pattern using ExpandoMetaClass</h6>
<div class="paragraph">
<p>The <a href="http://groovy.codehaus.org/ExpandoMetaClass">ExpandoMetaClass</a> allows usage of this pattern to be encapsulated in a library. This allows Groovy to emulate similar libraries available for the Ruby language.</p>
</div>
<div class="paragraph">
<p>Consider the following library class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class Delegator {
    private targetClass
    private delegate
    Delegator(targetClass, delegate) {
        this.targetClass = targetClass
        this.delegate = delegate
    }
    def delegate(String methodName) {
        delegate(methodName, methodName)
    }
    def delegate(String methodName, String asMethodName) {
        targetClass.metaClass."$asMethodName" = delegate.&amp;"$methodName"
    }
    def delegateAll(String[] names) {
        names.each { delegate(it) }
    }
    def delegateAll(Map names) {
        names.each { k, v -&gt; delegate(k, v) }
    }
    def delegateAll() {
        delegate.class.methods*.name.each { delegate(it) }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>With this in your classpath, you can now apply the delegation pattern dynamically as shown in the following examples. First, consider we have the following classes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class Person {
    String name
}

class MortgageLender {
    def borrowAmount(amount) {
       "borrow \\$$amount"
    }
    def borrowFor(thing) {
       "buy \\$thing"
    }
}

def lender = new MortgageLender()

def delegator = new Delegator(Person, lender)</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can now use the <em>delegator</em> to automatically borrow methods from the <em>lender</em> object to extend the <em>Person</em> class. We can borrow the methods as is or with a rename:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">delegator.delegate 'borrowFor'
delegator.delegate 'borrowAmount', 'getMoney'

def p = new Person()

println p.borrowFor('present')   // =&gt; buy present
println p.getMoney(50)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first line above, adds the <em>borrowFor</em> method to the <em>Person</em> class by delegating to the <em>lender</em> object. The second line adds a <em>getMoney</em> method to the <em>Person</em> class by delegating to the <em>lender</em> object&#8217;s <em>borrowAmount</em> method.</p>
</div>
<div class="paragraph">
<p>Alternatively, we could borrow multiple methods like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">delegator.delegateAll 'borrowFor', 'borrowAmount'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which adds these two methods to the <em>Person</em> class.</p>
</div>
<div class="paragraph">
<p>Or if we want all the methods, like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">delegator.delegateAll()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which will make all the methods in the delegate object available in the <em>Person</em> class.</p>
</div>
<div class="paragraph">
<p>Alternatively, we can use a map notation to rename multiple methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">delegator.delegateAll borrowAmount:'getMoney', borrowFor:'getThing'</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_implement_delegation_pattern_using_delegate_annotation">Implement Delegation Pattern using @Delegate annotation</h6>
<div class="paragraph">
<p>Since version 1.6 you can use the built-in delegation mechanism which is based on AST transformation.</p>
</div>
<div class="paragraph">
<p>This make delegation even easier:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class Person {
    def name
    @Delegate MortgageLender mortgageLender = new MortgageLender()
}

class MortgageLender {
    def borrowAmount(amount) {
       "borrow \\$$amount"
    }
    def borrowFor(thing) {
       "buy $thing"
    }
}

def p = new Person()

assert "buy present" == p.borrowFor('present')
assert "borrow \\$50" == p.borrowAmount(50)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_flyweight_pattern">Flyweight Pattern</h5>
<div class="paragraph">
<p>The <a href="http://en.wikipedia.org/wiki/Flyweight_pattern">Flyweight Pattern</a> is a pattern for greatly reducing memory requirements by not requiring that heavy-weight objects be created in large numbers when dealing with systems that contain many things that are mostly the same. If for instance, a document was modeled using a complex character class that knew about unicode, fonts, positioning, etc., then the memory requirements could be quite large for large documents if each physical character in the document required its own character class instance. Instead, characters themselves might be kept within Strings and we might have one character class (or a small number such as one character class for each font type) that knew the specifics of how to deal with characters.</p>
</div>
<div class="paragraph">
<p>In such circumstances, we call the state that is shared with many other things (e.g. the character type) <em>instrinsic</em> state. It is captured within the heavy-weight class. The state which distinguishes the physical character (maybe just its ASCII code or Unicode) is called its <em>extrinsic</em> state.</p>
</div>
<div class="sect5">
<h6 id="_example_4">Example</h6>
<div class="paragraph">
<p>First we are going to model some complex aircraft (the first being a hoax competitor of the second - not that is relevant to the example).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class Boeing797 {
    def wingspan = '80.8 m'
    def capacity = 1000
    def speed = '1046 km/h'
    def range = '14400 km'
    // ...
}</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="assets/img/b797-hoax.jpg" alt="b797 hoax">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class Airbus380 {
    def wingspan = '79.8 m'
    def capacity = 555
    def speed = '912 km/h'
    def range = '10370 km'
    // ...
}</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="assets/img/a380.jpg" alt="a380">
</div>
</div>
<div class="paragraph">
<p>If we want to model our fleet, our first attempt might involve using many instances of these heavy-weight objects. It turns out though that only a few small pieces of state (our extrinsic state) change for each aircraft, so we will have singletons for the heavy-weight objects and capture the extrinsic state (bought date and asset number in the code below) separately.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class FlyweightFactory {
    static instances = [797: new Boeing797(), 380: new Airbus380()]
}

class Aircraft {
    private type         // instrinsic state
    private assetNumber  // extrinsic state
    private bought       // extrinsic state
    Aircraft(typeCode, assetNumber, bought) {
        type = FlyweightFactory.instances[typeCode]
        this.assetNumber = assetNumber
        this.bought = bought
    }
    def describe() {
        println """
        Asset Number: $assetNumber
        Capacity: $type.capacity people
        Speed: $type.speed
        Range: $type.range
        Bought: $bought
        """
    }
}

def fleet = [
    new Aircraft(380, 1001, '10-May-2007'),
    new Aircraft(380, 1002, '10-Nov-2007'),
    new Aircraft(797, 1003, '10-May-2008'),
    new Aircraft(797, 1004, '10-Nov-2008')
]

fleet.each { p -&gt; p.describe() }</code></pre>
</div>
</div>
<div class="paragraph">
<p>So here, even if our fleet contained hundreds of planes, we would only have one heavy-weight object for each type of aircraft.</p>
</div>
<div class="paragraph">
<p>As a further efficiency measure, we might use lazy creation of the flyweight objects rather than create the initial map up front as in the above example.</p>
</div>
<div class="paragraph">
<p>Running this script results in:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Asset Number: 1001
Capacity: 555 people
Speed: 912 km/h
Range: 10370 km
Bought: 10-May-2007

Asset Number: 1002
Capacity: 555 people
Speed: 912 km/h
Range: 10370 km
Bought: 10-Nov-2007

Asset Number: 1003
Capacity: 1000 people
Speed: 1046 km/h
Range: 14400 km
Bought: 10-May-2008

Asset Number: 1004
Capacity: 1000 people
Speed: 1046 km/h
Range: 14400 km
Bought: 10-Nov-2008</pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_iterator_pattern">Iterator Pattern</h5>
<div class="paragraph">
<p>The <a href="http://en.wikipedia.org/wiki/Iterator_pattern">Iterator Pattern</a> allows sequential access to the elements of an aggregate object without exposing its underlying representation.</p>
</div>
<div class="paragraph">
<p>Groovy has the iterator pattern built right in to many of its closure operators, e.g. <code>each</code> and <code>eachWithIndex</code> as well as the <code>for .. in</code> loop.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">def printAll(container) {
    for (item in container) { println item }
}

def numbers = [ 1,2,3,4 ]
def months = [ Mar:31, Apr:30, May:31 ]
def colors = [ java.awt.Color.BLACK, java.awt.Color.WHITE ]
printAll numbers
printAll months
printAll colors</code></pre>
</div>
</div>
<div class="paragraph">
<p>Results in the output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1
2
3
4
May=31
Mar=31
Apr=30
java.awt.Color[r=0,g=0,b=0]
java.awt.Color[r=255,g=255,b=255]</pre>
</div>
</div>
<div class="paragraph">
<p>Another example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">colors.eachWithIndex { item, pos -&gt;
    println "Position $pos contains '$item'"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Results in:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Position 0 contains 'java.awt.Color[r=0,g=0,b=0]'
Position 1 contains 'java.awt.Color[r=255,g=255,b=255]'</pre>
</div>
</div>
<div class="paragraph">
<p>The iterator pattern is also built in to other special operators such as the <code>eachByte</code>, <code>eachFile</code>, <code>eachDir</code>, <code>eachLine</code>, <code>eachObject</code>, <code>eachMatch</code> operators for working with streams, URLs, files, directories and regular expressions matches.</p>
</div>
</div>
<div class="sect4">
<h5 id="_loan_my_resource_pattern">Loan my Resource Pattern</h5>
<div class="paragraph">
<p>The <a href="https://wiki.scala-lang.org/display/SYGN/Loan">Loan my Resource</a> pattern ensures that a resource is deterministically disposed of once it goes out of scope.</p>
</div>
<div class="paragraph">
<p>This pattern is built in to many Groovy helper methods. You should consider using it yourself if you need to work with resources in ways beyond what Groovy supports.</p>
</div>
<div class="sect5">
<h6 id="_example_5">Example</h6>
<div class="paragraph">
<p>Consider the following code which works with a file. First we might write some line to the file and then print its size:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">def f = new File('junk.txt')
f.withPrintWriter { pw -&gt;
    pw.println(new Date())
    pw.println(this.class.name)
}
println f.size()
// =&gt; 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>We could also read back the contents of the file a line at a time and print each line out:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">f.eachLine { line -&gt;
    println line
}
// =&gt;
// Mon Jun 18 22:38:17 EST 2007
// RunPattern</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that normal Java <code>Reader</code> and <code>PrintWriter</code> objects were used under the covers by Groovy but the code writer did not have to worry about explicitly creating or closing those resources. The built-in Groovy methods loan the respective reader or writer to the closure code and then tidy up after themselves. So, you are using this pattern without having to do any work.</p>
</div>
<div class="paragraph">
<p>Sometimes however, you wish to do things slightly differently to what you can get for free using Groovy&#8217;s built-in mechanisms. You should consider utilising this pattern within your own resource-handling operations.</p>
</div>
<div class="paragraph">
<p>Consider how you might process the list of words on each line within the file. We could actually do this one too using Groovy&#8217;s built-in functions, but bear with us and assume we have to do some resource handling ourselves. Here is how we might write the code without using this pattern:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">def reader = f.newReader()
reader.splitEachLine(' ') { wordList -&gt;
    println wordList
}
reader.close()
// =&gt;
// [ "Mon", "Jun", "18", "22:38:17", "EST", "2007" ]
// [ "RunPattern" ]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that we now have an explicit call to <code>close()</code> in our code. If we didn&#8217;t code it just right (here we didn&#8217;t surround the code in a <code>try &#8230; finally</code> block, we run the risk of leaving the file handle open.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s now apply the loan pattern. First, we&#8217;ll write a helper method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">def withListOfWordsForEachLine(File f, Closure c) {
    def r = f.newReader()
    try {
        r.splitEachLine(' ', c)
    } finally {
        r?.close()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, we can re-write our code as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">withListOfWordsForEachLine(f) { wordList -&gt;
    println wordList
}
// =&gt;
// [ "Mon", "Jun", "18", "22:38:17", "EST", "2007" ]
// [ "RunPattern" ]</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is much simpler and has removed the explicit <code>close()</code>. This is now catered for in one spot so we can apply the appropriate level of testing or reviewing in just one spot to be sure we have no problems.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_null_object_pattern">Null Object Pattern</h5>
<div class="paragraph">
<p>The <a href="http://en.wikipedia.org/wiki/Null_Object_pattern">Null Object Pattern</a> involves using a special object place-marker object representing null. Typically, if you have a reference to null, you can&#8217;t invoke <code>reference.field</code> or <code>reference.method()</code>. You receive the dreaded <code>NullPointerException</code>. The null object pattern uses a special object representing null, instead of using an actual <code>null</code>. This allows you to invoke field and method references on the null object. The result of using the null object should semantically be equivalent to <em>doing nothing</em>.</p>
</div>
<div class="sect5">
<h6 id="_simple_example">Simple Example</h6>
<div class="paragraph">
<p>Suppose we have the following system:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class Job {
    def salary
}

class Person {
    def name
    def Job job
}

def people = [
    new Person(name: 'Tom', job: new Job(salary: 1000)),
    new Person(name: 'Dick', job: new Job(salary: 1200)),
]

def biggestSalary = people.collect { p -&gt; p.job.salary }.max()
println biggestSalary</code></pre>
</div>
</div>
<div class="paragraph">
<p>When run, this prints out <code>1200</code>. Suppose now that we now invoke:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">people &lt;&lt; new Person(name: 'Harry')</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we now try to calculate <code>biggestSalary</code> again, we receive a null pointer exception.</p>
</div>
<div class="paragraph">
<p>To overcome this problem, we can introduce a <code>NullJob</code> class and change the above statement to become:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class NullJob extends Job { def salary = 0 }

people &lt;&lt; new Person(name: 'Harry', job: new NullJob())
biggestSalary = people.collect { p -&gt; p.job.salary }.max()
println biggestSalary</code></pre>
</div>
</div>
<div class="paragraph">
<p>This works as we require but it&#8217;s not always the best way to do this with Groovy. Groovy&#8217;s safe-dereference operator (<code>?.</code>) operator and null aware closures often allow Groovy to avoid the need to create a special null object or null class. This is illustrated by examining a groovier way to write the above example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">people &lt;&lt; new Person(name:'Harry')
biggestSalary = people.collect { p -&gt; p.job?.salary }.max()
println biggestSalary</code></pre>
</div>
</div>
<div class="paragraph">
<p>Two things are going on here to allow this to work. First of all, <code>max()</code> is <em>'null aware&#8217;</em> so that <code>[300, null, 400].max() == 400</code>. Secondly, with the <code>?.</code> operator, an expression like <code>p?.job?.salary</code> will be equal to null if <code>salary</code> is equal to null, or if <code>job</code> is equal to null or if <code>p</code> is equal to null. You don&#8217;t need to code a complex nested <code>if &#8230; then &#8230; else</code> to avoid a <code>NullPointerException</code>.</p>
</div>
</div>
<div class="sect5">
<h6 id="_tree_example">Tree Example</h6>
<div class="paragraph">
<p>Consider the following example where we want to calculate size, cumulative sum and cumulative product of all the values in a tree structure.</p>
</div>
<div class="paragraph">
<p>Our first attempt has special logic within the calculation methods to handle null values.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class NullHandlingTree {
    def left, right, value

    def size() {
        1 + (left ? left.size() : 0) + (right ? right.size() : 0)
    }

    def sum() {
       value + (left ? left.sum() : 0) + (right ? right.sum() : 0)
    }

    def product() {
       value * (left ? left.product() : 1) * (right ? right.product() : 1)
    }
}

def root = new NullHandlingTree(
    value: 2,
    left: new NullHandlingTree(
        value: 3,
        right: new NullHandlingTree(value: 4),
        left: new NullHandlingTree(value: 5)
    )
)

println root.size()
println root.sum()
println root.product()</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we introduce the null object pattern (here by defining the <code>NullTree</code> class), we can now simplify the logic in the <code>size()</code>, <code>sum()</code> and <code>product()</code> methods. These methods now much more clearly represent the logic for the normal (and now universal) case. Each of the methods within <code>NullTree</code> returns a value which represents doing nothing.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class Tree {
    def left = new NullTree(), right = new NullTree(), value

    def size() {
        1 + left.size() + right.size()
    }

    def sum() {
       value + left.sum() + right.sum()
    }

    def product() {
       value * left.product() * right.product()
    }
}

class NullTree {
    def size() { 0 }
    def sum() { 0 }
    def product() { 1 }
}

def root = new Tree(
    value: 2,
    left: new Tree(
        value: 3,
        right: new Tree(value: 4),
        left: new Tree(value: 5)
    )
)

println root.size()
println root.sum()
println root.product()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result of running either of these examples is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>4
14
120</pre>
</div>
</div>
<div class="paragraph">
<p>Note: a slight variation with the null object pattern is to combine it with the singleton pattern. So, we wouldn&#8217;t write <code>new NullTree()</code> wherever we needed a null object as shown above. Instead we would have a single null object instance which we would place within our data structures as needed.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_pimp_my_library_pattern">Pimp my Library Pattern</h5>
<div class="paragraph">
<p>The <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=179766">Pimp my Library</a> Pattern suggests an approach for extending a library that nearly does everything that you need but just needs a little more. It assumes that you do not have source code for the library of interest.</p>
</div>
<div class="sect5">
<h6 id="_example_6">Example</h6>
<div class="paragraph">
<p>Suppose we want to make use of the built-in Integer facilities in Groovy (which build upon the features already in Java). Those libraries have nearly all of the features we want but not quite everything. We may not have all of the source code to the Groovy and Java libraries so we can&#8217;t just change the library. Instead we augment the library. Groovy has a number of ways to do this. One way is to use a Category.</p>
</div>
<div class="paragraph">
<p>First, we&#8217;ll define a suitable category.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class EnhancedInteger {
    static boolean greaterThanAll(Integer self, Object[] others) {
        greaterThanAll(self, others)
    }
    static boolean greaterThanAll(Integer self, others) {
        others.every { self &gt; it }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We have added two methods which augment the Integer methods by providing the <code>greaterThanAll</code> method. Categories follow conventions where they are defined as static methods with a special first parameter representing the class we wish to extend. The <code>greaterThanAll(Integer self, others)</code> static method becomes the <code>greaterThanAll(other)</code> instance method.</p>
</div>
<div class="paragraph">
<p>We defined two versions of <code>greaterThanAll</code>. One which works for collections, ranges etc. The other which works with a variable number of <code>Integer</code> arguments.</p>
</div>
<div class="paragraph">
<p>Here is how you would use the category.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">use(EnhancedInteger) {
    assert 4.greaterThanAll(1, 2, 3)
    assert !5.greaterThanAll(2, 4, 6)
    assert 5.greaterThanAll(-4..4)
    assert 5.greaterThanAll([])
    assert !5.greaterThanAll([4, 5])
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, using this technique you can effectively enrich an original class without having access to its source code. Moreover, you can apply different enrichments in different parts of the system as well as work with un-enriched objects if we need to.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_proxy_pattern">Proxy Pattern</h5>
<div class="paragraph">
<p>The <a href="http://en.wikipedia.org/wiki/Proxy_pattern">Proxy Pattern</a> allows one object to act as a pretend replacement for some other object. In general, whoever is using the proxy, doesn&#8217;t realise that they are not using the real thing. The pattern is useful when the real object is hard to create or use: it may exist over a network connection, or be a large object in memory, or be a file, database or some other resource that is expensive or impossible to duplicate.</p>
</div>
<div class="sect5">
<h6 id="_example_7">Example</h6>
<div class="paragraph">
<p>One common use of the proxy pattern is when talking to remote objects in a different JVM. Here is the client code for creating a proxy that talks via sockets to a server object as well as an example usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class AccumulatorProxy {
    def accumulate(args) {
        def result
        def s = new Socket("localhost", 54321)
        s.withObjectStreams { ois, oos -&gt;
            oos &lt;&lt; args
            result = ois.readObject()
        }
        s.close()
        return result
    }
}

println new AccumulatorProxy().accumulate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
// =&gt; 55</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is what your server code might look like (start this first):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class Accumulator {
    def accumulate(args) {
        args.inject(0) { total, arg -&gt; total += arg }
    }
}

def port = 54321
def accumulator = new Accumulator()
def server = new ServerSocket(port)
println "Starting server on port $port"
while(true) {
    server.accept() { socket -&gt;
        socket.withObjectStreams { ois, oos -&gt;
            def args = ois.readObject()
            oos &lt;&lt; accumulator.accumulate(args)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_singleton_pattern">Singleton Pattern</h5>
<div class="paragraph">
<p>The <a href="http://en.wikipedia.org/wiki/Singleton_pattern">Singleton Pattern</a> is used to make sure only one object of a particular class is ever created. This can be useful when when exactly one object is needed to coordinate actions across a system; perhaps for efficiency where creating lots of identical objects would be wasteful, perhaps because a particular algorithm needing a single point of control is required or perhaps when an object is used to interact with a non-shareable resource.</p>
</div>
<div class="paragraph">
<p>Weaknesses of the Singleton pattern include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It can reduce reuse. For instance, there are issues if you want to use inheritance with Singletons. If <code>SingletonB</code> extends <code>SingletonA</code>, should there be exactly (at most) one instance of each or should the creation of an object from one of the classes prohibit creation from the other. Also, if you decide both classes can have an instance, how do you override the <code>getInstance()</code> method which is static?</p>
</li>
<li>
<p>It is also hard to test singletons in general because of the static methods but Groovy can support that if required.</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="_example_the_classic_java_singleton">Example: The Classic Java Singleton</h6>
<div class="paragraph">
<p>Suppose we wish to create a class for collecting votes. Because getting the right number of votes may be very important, we decide to use the singleton pattern. There will only ever be one <code>VoteCollector</code> object, so it makes it easier for us to reason about that objects creation and use.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class VoteCollector {
    def votes = 0
    private static final INSTANCE = new VoteCollector()
    static getInstance() { return INSTANCE }
    private VoteCollector() { }
    def display() { println "Collector:${hashCode()}, Votes:$votes" }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Some points of interest about this code:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>it has a private constructor, so no <code>VoteCollector</code> objects can be created in our system (except for the <code>INSTANCE</code> we create)</p>
</li>
<li>
<p>the <code>INSTANCE</code> is also private, so it can&#8217;t be changed once set</p>
</li>
<li>
<p>we haven&#8217;t made the updating of votes thread-safe at this point (it doesn&#8217;t add to this example)</p>
</li>
<li>
<p>the vote collector instance is not lazyily created (if we never reference the class, the instance won&#8217;t be created; however, as soon as we reference the class, the instance will be created even if not needed initially)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We can use this singleton class in some script code as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">def collector = VoteCollector.instance
collector.display()
collector.votes++
collector = null

Thread.start{
    def collector2 = VoteCollector.instance
    collector2.display()
    collector2.votes++
    collector2 = null
}.join()

def collector3 = VoteCollector.instance
collector3.display()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we used the instance 3 times. The second usage was even in a different thread (but don&#8217;t try this in a scenario with a new class loader).</p>
</div>
<div class="paragraph">
<p>Running this script yields (your hashcode value will vary):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Collector:15959960, Votes:0
Collector:15959960, Votes:1
Collector:15959960, Votes:2</pre>
</div>
</div>
<div class="paragraph">
<p>Variations to this pattern:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>To support lazy-loading and multi-threading, we could just use the <code>synchronized</code> keyword with the <code>getInstance()</code> method. This has a performance hit but will work.</p>
</li>
<li>
<p>We can consider variations involving double-checked locking and the <code>volatile</code> keyword (for Java 5 and above), but see the limitations of this approach <a href="http://www.ibm.com/developerworks/java/library/j-dcl/index.html">here</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="_example_singleton_via_metaprogramming">Example: Singleton via MetaProgramming</h6>
<div class="paragraph">
<p>Groovy&#8217;s meta-programming capabilities allow concepts like the singleton pattern to be enacted in a far more fundamental way. This example illustrates a simple way to use Groovy&#8217;s meta-programming capabilities to achieve the singleton pattern but not necessarily the most efficient way.</p>
</div>
<div class="paragraph">
<p>Suppose we want to keep track of the total number of calculations that a calculator performs. One way to do that is to use a singleton for the calculator class and keep a variable in the class with the count.</p>
</div>
<div class="paragraph">
<p>First we define some base classes. A <code>Calculator</code> class which performs calculations and records how many such calculations it performs and a <code>Client</code> class which acts as a facade to the calculator.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class Calculator {
    private total = 0
    def add(a, b) { total++; a + b }
    def getTotalCalculations() { 'Total Calculations: ' + total }
    String toString() { 'Calc: ' + hashCode() }
}

class Client {
    def calc = new Calculator()
    def executeCalc(a, b) { calc.add(a, b) }
    String toString() { 'Client: ' + hashCode() }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we can define and register a <em>MetaClass</em> which intercepts all attempts to create a <code>Calculator</code> object and always provides a pre-created instance instead. We also register this MetaClass with the Groovy system:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class CalculatorMetaClass extends MetaClassImpl {
    private final static INSTANCE = new Calculator()
    CalculatorMetaClass() { super(Calculator) }
    def invokeConstructor(Object[] arguments) { return INSTANCE }
}

def registry = GroovySystem.metaClassRegistry
registry.setMetaClass(Calculator, new CalculatorMetaClass())</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we use instances of our <code>Client</code> class from within a script. The client class will attempt to create new instances of the calculator but will always get the singleton.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">def client = new Client()
assert 3 == client.executeCalc(1, 2)
println "$client, $client.calc, $client.calc.totalCalculations"

client = new Client()
assert 4 == client.executeCalc(2, 2)
println "$client, $client.calc, $client.calc.totalCalculations"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is the result of running this script (your hashcode values may vary):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Client: 7306473, Calc: 24230857, Total Calculations: 1
Client: 31436753, Calc: 24230857, Total Calculations: 2</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_guice_example">Guice Example</h6>
<div class="paragraph">
<p>We can also implement the Singleton Pattern using <a href="http://code.google.com/p/google-guice/">Guice</a>. This example relies on annotations. Annotations are a Groovy 1.1 feature and will need to be run on a Java 5 or above JVM.</p>
</div>
<div class="paragraph">
<p>Consider the Calculator example again.</p>
</div>
<div class="paragraph">
<p>Guice is a Java-oriented framework that supports Interface-Oriented design. Hence we create a <code>Calculator</code> interface first. We can then create our <code>CalculatorImpl</code> implementation and a <code>Client</code> object which our script will interact with. The <code>Client</code> class isn&#8217;t strictly needed for this example but allows us to show that non-singleton instances are the default. Here is the code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">@Grapes([@Grab('aopalliance:aopalliance:1.0'), @Grab('com.google.code.guice:guice:1.0')])
import com.google.inject.*

interface Calculator {
    def add(a, b)
}

class CalculatorImpl implements Calculator {
    private total = 0
    def add(a, b) { total++; a + b }
    def getTotalCalculations() { 'Total Calculations: ' + total }
    String toString() { 'Calc: ' + hashCode() }
}

class Client {
    @Inject Calculator calc
    def executeCalc(a, b) { calc.add(a, b) }
    String toString() { 'Client: ' + hashCode() }
}

def injector = Guice.createInjector (
    [configure: { binding -&gt;
        binding.bind(Calculator)
               .to(CalculatorImpl)
               .asEagerSingleton() } ] as Module
)

def client = injector.getInstance(Client)
assert 3 == client.executeCalc(1, 2)
println "$client, $client.calc, $client.calc.totalCalculations"

client = injector.getInstance(Client)
assert 4 == client.executeCalc(2, 2)
println "$client, $client.calc, $client.calc.totalCalculations"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note the <code>@Inject</code> annotation in the <code>Client</code> class. We can always tell right in the source code which fields will be injected.</p>
</div>
<div class="paragraph">
<p>In this example we chose to use an <em>explicit</em> binding. All of our dependencies (ok, only one in this example at the moment) are configured in the binding. The Guide injector knows about the binding and injects the dependencies as required when we create objects. For the singleton pattern to hold, you must always use Guice to create your instances. Nothing shown so far would stop you creating another instance of the calculator manually using <code>new CalculatorImpl()</code> which would of course violate the desired singleton behaviour.</p>
</div>
<div class="paragraph">
<p>In other scenarios (though probably not in large systems), we could choose to express dependencies using annotations, such as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">@Grapes([@Grab('aopalliance:aopalliance:1.0'), @Grab('com.google.code.guice:guice:1.0')])
import com.google.inject.*

@ImplementedBy(CalculatorImpl)
interface Calculator {
    // as before ...
}

@Singleton
class CalculatorImpl implements Calculator {
    // as before ...
}

class Client {
    // as before ...
}

def injector = Guice.createInjector()

// ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note the <code>@Singleton</code> annotation on the <code>CalculatorImpl</code> class and the <code>@ImplementedBy</code> annotation in the <code>Calculator</code> interface.</p>
</div>
<div class="paragraph">
<p>When run, the above example (using either approach) yields (your hashcode values will vary):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Client: 8897128, Calc: 17431955, Total Calculations: 1
Client: 21145613, Calc: 17431955, Total Calculations: 2</pre>
</div>
</div>
<div class="paragraph">
<p>You can see that we obtained a new client object whenever we asked for an instance but it was injected with the same calculator object.</p>
</div>
</div>
<div class="sect5">
<h6 id="_spring_example">Spring Example</h6>
<div class="paragraph">
<p>We can do the Calculator example again using Spring as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">@Grapes([@Grab('org.springframework:spring-core:3.2.2.RELEASE'), @Grab('org.springframework:spring-beans:3.2.2.RELEASE')])
import org.springframework.beans.factory.support.*

interface Calculator {
    def add(a, b)
}

class CalculatorImpl implements Calculator {
    private total = 0
    def add(a, b) { total++; a + b }
    def getTotalCalculations() { 'Total Calculations: ' + total }
    String toString() { 'Calc: ' + hashCode() }
}

class Client {
    Client(Calculator calc) { this.calc = calc }
    def calc
    def executeCalc(a, b) { calc.add(a, b) }
    String toString() { 'Client: ' + hashCode() }
}

// Here we 'wire' up our dependencies through the API. Alternatively,
// we could use XML-based configuration or the Grails Bean Builder DSL.
def factory = new DefaultListableBeanFactory()
factory.registerBeanDefinition('calc', new RootBeanDefinition(CalculatorImpl))
def beanDef = new RootBeanDefinition(Client, false)
beanDef.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_AUTODETECT)
factory.registerBeanDefinition('client', beanDef)

def client = factory.getBean('client')
assert 3 == client.executeCalc(1, 2)
println "$client, $client.calc, $client.calc.totalCalculations"

client = factory.getBean('client')
assert 4 == client.executeCalc(2, 2)
println "$client, $client.calc, $client.calc.totalCalculations"</code></pre>
</div>
</div>
<div class="paragraph">
<p>And here is the result (your hashcode values will vary):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Client: 29418586, Calc: 10580099, Total Calculations: 1
Client: 14800362, Calc: 10580099, Total Calculations: 2</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_further_information">Further information</h6>
<div class="ulist">
<ul>
<li>
<p><a href="http://www.javaworld.com/javaworld/jw-04-2003/jw-0425-designpatterns.html?page=1">Simply Singleton</a></p>
</li>
<li>
<p><a href="http://www.ibm.com/developerworks/webservices/library/co-single/index.html">Use your singletons wisely</a></p>
</li>
<li>
<p><a href="http://www.ibm.com/developerworks/java/library/j-dcl/index.html">Double-checked locking and the Singleton pattern</a></p>
</li>
<li>
<p><a href="http://crazybob.org/2007/01/lazy-loading-singletons.html">Lazy Loading Singletons</a></p>
</li>
<li>
<p><a href="http://www.yoda.arachsys.com/csharp/singleton.html">Implementing the Singleton Pattern in C#</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_state_pattern">State Pattern</h5>
<div class="paragraph">
<p>The <a href="http://en.wikipedia.org/wiki/State_pattern">State Pattern</a> provides a structured approach to partitioning the behaviour within complex systems. The overall behaviour of a system is partitioned into well-defined states. Typically, each state is implemented by a class. The overall system behaviour can be determined firstly by knowing the <em>current state</em> of the system; secondly, by understanding the behaviour possible while in that state (as embodied in the methods of the class corresponding to that state).</p>
</div>
<div class="sect5">
<h6 id="_example_8">Example</h6>
<div class="paragraph">
<p>Here is an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class Client {
    def context = new Context()
    def connect() {
        context.state.connect()
    }
    def disconnect() {
        context.state.disconnect()
    }
    def send_message(message) {
        context.state.send_message(message)
    }
    def receive_message() {
        context.state.receive_message()
    }
}

class Context {
    def state = new Offline(this)
}

class ClientState {
    def context
    ClientState(context) {
        this.context = context
        inform()
    }
}

class Offline extends ClientState {
    Offline(context) {
        super(context)
    }
    def inform() {
        println "offline"
    }
    def connect() {
        context.state = new Online(context)
    }
    def disconnect() {
        println "error: not connected"
    }
    def send_message(message) {
        println "error: not connected"
    }
    def receive_message() {
        println "error: not connected"
    }
}

class Online extends ClientState {
    Online(context) {
        super(context)
    }
    def inform() {
        println "connected"
    }
    def connect() {
        println "error: already connected"
    }
    def disconnect() {
        context.state = new Offline(context)
    }
    def send_message(message) {
        println "\"$message\" sent"
    }
    def receive_message() {
        println "message received"
    }
}

client = new Client()
client.send_message("Hello")
client.connect()
client.send_message("Hello")
client.connect()
client.receive_message()
client.disconnect()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is the output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>offline
error: not connected
connected
"Hello" sent
error: already connected
message received
offline</pre>
</div>
</div>
<div class="paragraph">
<p>One of the great things about a dynamic language like Groovy though is that we can take this example and express it in many different ways depending on our particular needs. Some potential variations for this example are shown below.</p>
</div>
</div>
<div class="sect5">
<h6 id="_variation_1_leveraging_interface_oriented_design">Variation 1: Leveraging Interface-Oriented Design</h6>
<div class="paragraph">
<p>One approach we could take is to leverage <a href="http://www.pragmaticprogrammer.com/titles/kpiod/index.html">Interface-Oriented Design</a>. To do this, we could introduce the following interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">interface State {
    def connect()
    def disconnect()
    def send_message(message)
    def receive_message()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then our <code>Client</code>, <code>Online</code> and <code>Offline</code> classes could be modified to implement that interface, e.g.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class Client implements State {
  // ... as before ...
}

class Online implements State {
  // ... as before ...
}

class Offline implements State {
  // ... as before ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You might ask: Haven&#8217;t we just introduced additional boilerplate code? Can&#8217;t we rely on duck-typing for this? The answer is <em>yes</em> and <em>no</em>. We can get away with duck-typing but one of the key intentions of the state pattern is to partition complexity. If we know that the <em>client</em> class and each <em>state</em> class all satisfy one interface, then we have placed some key boundaries around the complexity. We can look at any state class in isolation and know the bounds of behaviour possible for that state.</p>
</div>
<div class="paragraph">
<p>We don&#8217;t have to use interfaces for this, but it helps express the intent of this particular style of partitioning and it helps reduce the size of our unit tests (we would have to have additional tests in place to express this intent in languages which have less support for interface-oriented design).</p>
</div>
</div>
<div class="sect5">
<h6 id="_variation_2_extract_state_pattern_logic">Variation 2: Extract State Pattern Logic</h6>
<div class="paragraph">
<p>Alternatively, or in combination with other variations, we might decide to extract some of our State Pattern logic into helper classes. For example, we could define the following classes in a state pattern package/jar/script:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">abstract class InstanceProvider {
    static def registry = GroovySystem.metaClassRegistry
    static def create(objectClass, param) {
        registry.getMetaClass(objectClass).invokeConstructor([param] as Object[])
    }
}

abstract class Context {
    private context
    protected setContext(context) {
        this.context = context
    }
    def invokeMethod(String name, Object arg) {
        context.invokeMethod(name, arg)
    }
    def startFrom(initialState) {
        setContext(InstanceProvider.create(initialState, this))
    }
}

abstract class State {
    private client

    State(client) { this.client = client }

    def transitionTo(nextState) {
        client.setContext(InstanceProvider.create(nextState, client))
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is all quite generic and can be used wherever we want to introduce the state pattern. Here is what our code would look like now:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class Client extends Context {
    Client() {
        startFrom(Offline)
    }
}

class Offline extends State {
    Offline(client) {
        super(client)
        println "offline"
    }
    def connect() {
        transitionTo(Online)
    }
    def disconnect() {
        println "error: not connected"
    }
    def send_message(message) {
        println "error: not connected"
    }
    def receive_message() {
        println "error: not connected"
    }
}

class Online extends State {
    Online(client) {
        super(client)
        println "connected"
    }
    def connect() {
        println "error: already connected"
    }
    def disconnect() {
        transitionTo(Offline)
    }
    def send_message(message) {
        println "\"$message\" sent"
    }
    def receive_message() {
        println "message received"
    }
}

client = new Client()
client.send_message("Hello")
client.connect()
client.send_message("Hello")
client.connect()
client.receive_message()
client.disconnect()</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can see here the <code>startFrom</code> and <code>transitionTo</code> methods begin to give our example code a DSL feel.</p>
</div>
</div>
<div class="sect5">
<h6 id="_variation_3_bring_on_the_dsl">Variation 3: Bring on the DSL</h6>
<div class="paragraph">
<p>Alternatively, or in combination with other variations, we might decide to fully embrace a Domain Specific Language (DSL) approach to this example.</p>
</div>
<div class="paragraph">
<p>We can define the following generic helper functions (first discussed <a href="http://www.bytemycode.com/snippets/snippet/640/">here</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class Grammar {
    def fsm

    def event
    def fromState
    def toState

    Grammar(a_fsm) {
        fsm = a_fsm
    }

    def on(a_event) {
        event = a_event
        this
    }

    def on(a_event, a_transitioner) {
        on(a_event)
        a_transitioner.delegate = this
        a_transitioner.call()
        this
    }

    def from(a_fromState) {
        fromState = a_fromState
        this
    }

    def to(a_toState) {
        assert a_toState, "Invalid toState: $a_toState"
        toState = a_toState
        fsm.registerTransition(this)
        this
    }

    def isValid() {
        event &amp;&amp; fromState &amp;&amp; toState
    }

    public String toString() {
        "$event: $fromState=&gt;$toState"
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class FiniteStateMachine {
    def transitions = [:]

    def initialState
    def currentState

    FiniteStateMachine(a_initialState) {
        assert a_initialState, "You need to provide an initial state"
        initialState = a_initialState
        currentState = a_initialState
    }

    def record() {
        Grammar.newInstance(this)
    }

    def reset() {
        currentState = initialState
    }

    def isState(a_state) {
        currentState == a_state
    }

    def registerTransition(a_grammar) {
        assert a_grammar.isValid(), "Invalid transition ($a_grammar)"
        def transition
        def event = a_grammar.event
        def fromState = a_grammar.fromState
        def toState = a_grammar.toState

        if (!transitions[event]) {
            transitions[event] = [:]
        }

        transition = transitions[event]
        assert !transition[fromState], "Duplicate fromState $fromState for transition $a_grammar"
        transition[fromState] = toState
    }

    def fire(a_event) {
        assert currentState, "Invalid current state '$currentState': passed into constructor"
        assert transitions.containsKey(a_event), "Invalid event '$a_event', should be one of ${transitions.keySet()}"
        def transition = transitions[a_event]
        def nextState = transition[currentState]
        assert nextState, "There is no transition from '$currentState' to any other state"
        currentState = nextState
        currentState
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we can define and test our state machine like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class StatePatternDslTest extends GroovyTestCase {
    private fsm

    protected void setUp() {
        fsm = FiniteStateMachine.newInstance('offline')
        def recorder = fsm.record()
        recorder.on('connect').from('offline').to('online')
        recorder.on('disconnect').from('online').to('offline')
        recorder.on('send_message').from('online').to('online')
        recorder.on('receive_message').from('online').to('online')
    }

    void testInitialState() {
        assert fsm.isState('offline')
    }

    void testOfflineState() {
        shouldFail{
            fsm.fire('send_message')
        }
        shouldFail{
            fsm.fire('receive_message')
        }
        shouldFail{
            fsm.fire('disconnect')
        }
        assert 'online' == fsm.fire('connect')
    }

    void testOnlineState() {
        fsm.fire('connect')
        fsm.fire('send_message')
        fsm.fire('receive_message')
        shouldFail{
            fsm.fire('connect')
        }
        assert 'offline' == fsm.fire('disconnect')
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This example isn&#8217;t an exact equivalent of the others. It doesn&#8217;t use predefined <code>Online</code> and <code>Offline</code> classes. Instead it defines the entire state machine on the fly as needed. See the <a href="http://www.bytemycode.com/snippets/snippet/640/">previous reference</a> for more elaborate examples of this style.</p>
</div>
<div class="paragraph">
<p>See also: <a href="#_model_based_testing_using_modeljunit">Model-based testing using ModelJUnit</a></p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_strategy_pattern">Strategy Pattern</h5>
<div class="paragraph">
<p>The <a href="http://en.wikipedia.org/wiki/Strategy_pattern">Strategy Pattern</a> allows you to abstract away particular algorithms from their usage. This allows you to easily swap the algorithm being used without having to change the calling code. The general form of the pattern is:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="assets/img/StrategyClasses.gif" alt="StrategyClasses">
</div>
</div>
<div class="paragraph">
<p>In Groovy, because of its ability to treat code as a first class object using anonymous methods (which we loosely call <em>Closures</em>), the need for the strategy pattern is greatly reduced. You can simply place algorithms inside Closures.</p>
</div>
<div class="sect5">
<h6 id="_example_9">Example</h6>
<div class="paragraph">
<p>First let&#8217;s look at the traditional way of encapsulating the Strategy Pattern.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">interface Calc {
    def execute(n, m)
}

class CalcByMult implements Calc {
    def execute(n, m) { n * m }
}

class CalcByManyAdds implements Calc {
    def execute(n, m) {
        def result = 0
        n.times{
            result += m
        }

        result
    }
}

def sampleData = [
    [3, 4, 12],
    [5, -5, -25]
]

Calc[] multiplicationStrategies = [
    new CalcByMult(),
    new CalcByManyAdds()
]

sampleData.each{ data -&gt;
    multiplicationStrategies.each { calc -&gt;
        assert data[2] == calc.execute(data[0], data[1])
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we have defined an interface <code>Calc</code> which our concrete strategy classes will implement (we could also have used an abstract class). We then defined two algorithms for doing simple multiplication: <code>CalcByMult</code> the normal way, and <code>CalcByManyAdds</code> using only addition (don&#8217;t try this one using negative numbers - yes we could fix this but it would just make the example longer). We then use normal <a href="http://en.wikipedia.org/wiki/Polymorphism_in_object-oriented_programming">polymorphism</a> to invoke the algorithms.</p>
</div>
<div class="paragraph">
<p>Here is the Groovier way to achieve the same thing using Closures:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">def multiplicationStrategies = [
    { n, m -&gt; n * m },
    { n, m -&gt; def result = 0; n.times{ result += m }; result }
]

def sampleData = [
    [3, 4, 12],
    [5, -5, -25]
]

sampleData.each{ data -&gt;
    multiplicationStrategies.each { calc -&gt;
        assert data[2] == calc(data[0], data[1])
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_template_method_pattern">Template Method Pattern</h5>
<div class="paragraph">
<p>The <a href="http://en.wikipedia.org/wiki/Template_method_pattern">Template Method Pattern</a> abstracts away the details of several algorithms. The generic part of an algorithm is contained within a base class. Particular implementation details are captured within base classes. The generic pattern of classes involved looks like this:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="assets/img/TemplateMethodClasses.gif" alt="TemplateMethodClasses">
</div>
</div>
<div class="sect5">
<h6 id="_example_10">Example</h6>
<div class="paragraph">
<p>In this example, <code>Accumulator</code> captures the essence of the accumulation algorithm. The base classes <code>Sum</code> and <code>Product</code> provide particular customised ways to use the generic accumulation algorithm.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">abstract class Accumulator {
    protected initial
    abstract doAccumulate(total, v)
    def accumulate(values) {
        def total = initial
        values.each { v -&gt; total = doAccumulate(total, v) }
        total
    }
}

class Sum extends Accumulator {
    def Sum() { initial = 0 }
    def doAccumulate(total, v) { total + v }
}

class Product extends Accumulator {
    def Product() { initial = 1 }
    def doAccumulate(total, v) { total * v }
}

println new Sum().accumulate([1,2,3,4])
println new Product().accumulate([1,2,3,4])</code></pre>
</div>
</div>
<div class="paragraph">
<p>The resulting output is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>10
24</pre>
</div>
</div>
<div class="paragraph">
<p>In this particular case, you could use Groovy&#8217;s inject method to achieve a similar result using Closures:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">Closure addAll = { total, item -&gt; total += item }
def accumulated = [1, 2, 3, 4].inject(0, addAll)
println accumulated    // =&gt; 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>Thanks to duck-typing, this would also work with other objects which support an add (plus() in Groovy) method, e.g.:</p>
</div>
<div class="paragraph">
<p>In this particular case, you could use Groovy&#8217;s inject method to achieve a similar result using Closures:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">accumulated = [ "1", "2", "3", "4" ].inject("", addAll)
println accumulated    // =&gt; "1234"</code></pre>
</div>
</div>
<div class="paragraph">
<p>We could also do the multiplication case as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">Closure multAll = { total, item -&gt; total *= item }
accumulated = [1, 2, 3, 4].inject(1, multAll)
println accumulated    // =&gt; 24</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using closures this way looks more like the <a href="#_strategy_pattern">Strategy Pattern</a> but if we realise that the built-in <code>inject</code> method is the generic part of the algorithm for our template method, then the Closures become the customised parts of the template method pattern.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_visitor_pattern">Visitor Pattern</h5>
<div class="paragraph">
<p>The <a href="http://en.wikipedia.org/wiki/Visitor_pattern">Visitor Pattern</a> is one of those well-known but not often used patterns. I think this is strange, as it is really a nice thing.</p>
</div>
<div class="paragraph">
<p>The goal of the pattern is to separate an algorithm from an object structure. A practical result of this separation is the ability to add new operations to existing object structures without modifying those structures.</p>
</div>
<div class="sect5">
<h6 id="_simple_example_2">Simple Example</h6>
<div class="paragraph">
<p>This example considers how to calculate the bounds of shapes (or collections of shapes). Our first attempt uses the traditional visitor pattern. We will see a more Groovy way to do this shortly.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">abstract class Shape { }

class Rectangle extends Shape {
    def x, y, width, height

    Rectangle(x, y, width, height) {
        this.x = x; this.y = y; this.width = width; this.height = height
    }

    def union(rect) {
        if (!rect) return this
        def minx = [rect.x, x].min()
        def maxx = [rect.x + width, x + width].max()
        def miny = [rect.y, y].min()
        def maxy = [rect.y + height, y + height].max()
        new Rectangle(minx, miny, maxx - minx, maxy - miny)
    }

    def accept(visitor) {
        visitor.visit_rectangle(this)
    }
}

class Line extends Shape {
    def x1, y1, x2, y2

    Line(x1, y1, x2, y2) {
        this.x1 = x1; this.y1 = y1; this.x2 = x2; this.y2 = y2
    }

    def accept(visitor){
        visitor.visit_line(this)
    }
}

class Group extends Shape {
    def shapes = []
    def add(shape) { shapes += shape }
    def remove(shape) { shapes -= shape }
    def accept(visitor) {
        visitor.visit_group(this)
    }
}

class BoundingRectangleVisitor {
    def bounds

    def visit_rectangle(rectangle) {
        if (bounds)
            bounds = bounds.union(rectangle)
        else
            bounds = rectangle
    }

    def visit_line(line) {
        def line_bounds = new Rectangle(line.x1, line.y1, line.x2-line.y1, line.x2-line.y2)
        if (bounds)
            bounds = bounds.union(line_bounds)
        else
            bounds = line_bounds
    }

    def visit_group(group) {
        group.shapes.each { shape -&gt; shape.accept(this) }
    }
}

def group = new Group()
group.add(new Rectangle(100, 40, 10, 5))
group.add(new Rectangle(100, 70, 10, 5))
group.add(new Line(90, 30, 60, 5))
def visitor = new BoundingRectangleVisitor()
group.accept(visitor)
bounding_box = visitor.bounds
println bounding_box.dump()</code></pre>
</div>
</div>
<div class="paragraph">
<p>That took quite a bit of code.</p>
</div>
<div class="paragraph">
<p>We can improve the clarity of our code (and make it about half the size) by making use of Groovy Closures as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">abstract class Shape {
    def accept(Closure yield) { yield(this) }
}

class Rectangle extends Shape {
    def x, y, w, h
    def bounds() { this }
    def union(rect) {
        if (!rect) return this
        def minx = [ rect.x, x ].min()
        def maxx = [ rect.x + w, x + w ].max()
        def miny = [ rect.y, y ].min()
        def maxy = [ rect.y + h, y + h ].max()
        new Rectangle(x:minx, y:miny, w:maxx - minx, h:maxy - miny)
    }
}

class Line extends Shape {
    def x1, y1, x2, y2
    def bounds() {
        new Rectangle(x:[x1, x2].min(), y:[y1, y2].min(), w:(x2 - x1).abs(), h:(y2 - y1).abs())
    }
}

class Group {
    def shapes = []
    def leftShift(shape) { shapes += shape }
    def accept(Closure yield) { shapes.each{it.accept(yield)} }
}

def group = new Group()
group &lt;&lt; new Rectangle(x:100, y:40, w:10, h:5)
group &lt;&lt; new Rectangle(x:100, y:70, w:10, h:5)
group &lt;&lt; new Line(x1:90, y1:30, x2:60, y2:5)
def bounds
group.accept{ bounds = it.bounds().union(bounds) }
println bounds.dump()</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_advanced_example">Advanced Example</h6>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">interface Visitor {
    void visit(NodeType1 n1)
    void visit(NodeType2 n2)
}

interface Visitable {
    void accept(Visitor visitor)
}

class NodeType1 implements Visitable {
    Visitable[] children = new Visitable[0]
    void accept(Visitor visitor) {
        visitor.visit(this)
        for(int i = 0; i &lt; children.length; ++i) {
            children[i].accept(visitor)
        }
    }
}

class NodeType2 implements Visitable {
    Visitable[] children = new Visitable[0]
    void accept(Visitor visitor) {
        visitor.visit(this)
        for(int i = 0; i &lt; children.length; ++i) {
            children[i].accept(visitor)
        }
    }
}

class NodeType1Counter implements Visitor {
    int count = 0
    void visit(NodeType1 n1) {
        count++
    }
    void visit(NodeType2 n2){}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we now use <code>NodeType1Counter</code> on a tree like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">NodeType1 root = new NodeType1()
root.children = new Visitable[2]
root.children[0] = new NodeType1()
root.children[1] = new NodeType2()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then we have one <code>NodeType1</code> object as root and one of the children is also a <code>NodeType1</code> instance. The other child is a <code>NodeType2</code> instance. That means using <code>NodeType1Counter</code> here should count 2 <code>NodeType1</code> objects.</p>
</div>
<div class="sect6">
<h7 id="_why_to_use_this">Why to use this</h7>
<div class="paragraph">
<p>As you can see here very good we have a visitor that has a state while the tree of objects is not changed. That&#8217;s pretty useful in different areas, for example you could have a visitor counting all node types, or how many different types are used, or you could use methods special to the node to gather information about the tree and much more.</p>
</div>
</div>
<div class="sect6">
<h7 id="_what_happens_if_we_add_a_new_type">What happens if we add a new type?</h7>
<div class="paragraph">
<p>In this case we have to do much work.. we have to change Visitor to accept the new type, we have to write the new type itself of course and we have to change every Visitor we have already implemented. After very few changes you will modify all your Visitors to extend a default implementation of the visitor, so you don&#8217;t need to change every Visitor each time you add a new type.</p>
</div>
</div>
<div class="sect6">
<h7 id="_what_if_we_want_to_have_different_iteration_patterns">What if we want to have different iteration patterns?</h7>
<div class="paragraph">
<p>Then you have a problem. since the node describes how to iterate, you have no influence and stop iteration at a point or change the order. So maybe we should change this a little to this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">interface Visitor {
    void visit(NodeType1 n1)
    void visit(NodeType2 n2)
}

class DefaultVisitor implements Visitor{
    void visit(NodeType1 n1) {
        for(int i = 0; i &lt; n1.children.length; ++i) {
            n1.children[i].accept(this)
        }
    }
    void visit(NodeType2 n2) {
        for(int i = 0; i &lt; n2.children.length; ++i) {
            n2.children[i].accept(this)
        }
    }
}

interface Visitable {
    void accept(Visitor visitor)
}

class NodeType1 implements Visitable {
    Visitable[] children = new Visitable[0]
    void accept(Visitor visitor) {
        visitor.visit(this)
    }
}

class NodeType2 implements Visitable {
    Visitable[] children = new Visitable[0];
    void accept(Visitor visitor) {
        visitor.visit(this)
    }
}

class NodeType1Counter extends DefaultVisitor {
    int count = 0
    void visit(NodeType1 n1) {
        count++
        super.visit(n1)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Some small changes but with big effect&#8230; the visitor is now recursive and tells me how to iterate. The implementation in the Nodes is minimized to <code>visitor.visit(this)</code>, <code>DefaultVisitor</code> is now able to catch the new types, we can stop iteration by not delegating to super. Of course the big disadvantage now is that it is no longer iterative, but you can&#8217;t get all the benefits.</p>
</div>
</div>
<div class="sect6">
<h7 id="_make_it_groovy">Make it Groovy</h7>
<div class="paragraph">
<p>The question now is how to make that a bit more Groovy. Didn&#8217;t you find this <code>visitor.visit(this)</code> strange? Why is it there? The answer is to simulate double dispatch. In Java the compile time type is used, so when I <code>visitor.visit(children[i])</code> then the compiler won&#8217;t be able to find the correct method, because <code>Visitor</code> does not contain a method <code>visit(Visitable)</code>. And even if it would, we would like to visit the more special methods with <code>NodeType1</code> or <code>NodeType2</code>.</p>
</div>
<div class="paragraph">
<p>Now Groovy is not using the static type, Groovy uses the runtime type. This means I could do <code>visitor.visit(children[i])</code> directly. Hmm.. since we minimized the accept method to just do the double dispatch part and since the runtime type system of Groovy will already cover that.. do we need the accept method? I think you can guess that I would answer no. But we can do more. We had the disadvantage of not knowing how to handle unknown tree elements. We had to extends the interface <code>Visitor</code> for that, resulting in changes to <code>DefaultVisitor</code> and then we have the task to provide a useful default like iterating the node or not doing anything at all. Now with Groovy we can catch that case by adding a <code>visit(Visitable)</code> method that does nothing. That would be the same in Java btw.</p>
</div>
<div class="paragraph">
<p>But don&#8217;t let us stop here&#8230; do we need the Visitor interface? If we don&#8217;t have the accept method, then we don&#8217;t need the <code>Visitor</code> interface at all. So the new code would be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class DefaultVisitor {
    void visit(NodeType1 n1) {
        n1.children.each { visit(it) }
    }
    void visit(NodeType2 n2) {
        n2.children.each { visit(it) }
    }
    void visit(Visitable v) { }
}

interface Visitable { }

class NodeType1 implements Visitable {
    Visitable[] children = []
}

class NodeType2 implements Visitable {
    Visitable[] children = []
}

class NodeType1Counter extends DefaultVisitor {
    int count = 0
    void visit(NodeType1 n1) {
        count++
        super.visit(n1)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Looks like we saved a few lines of code here. But we made more. The Visitable nodes now do not refer to any <code>Visitor</code> class or interface. For me this is the best level of separation you could get here. But do we really need to stop here? No. Let us change the <code>Visitable</code> interface a little and let it return the children we want to visit next. This allows us a general iteration method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class DefaultVisitor {
    void visit(Visitable v) {
        doIteraton(v)
    }
    void doIteraton(Visitable v) {
        v.children.each {
            visit(it)
        }
    }
}

interface Visitable {
    Visitable[] getChildren()
}

class NodeType1 implements Visitable {
    Visitable[] children = []
}

class NodeType2 implements Visitable {
    Visitable[] children = []
}

class NodeType1Counter extends DefaultVisitor {
    int count = 0
    void visit(NodeType1 n1) {
        count++
        super.visit(n1)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>DefaultVisitor</code> now looks a bit different. I added a <code>doIteration</code> method that will get the children it should iterate over and then call visit on each element. Per default this will call <code>visit(Visitable)</code> which then iterates over the children of this child. I changed <code>Visitable</code> to ensure that any node will be able to return children (even if empty). I didn&#8217;t have to change the <code>NodeType1</code> and <code>NodeType2</code> class, because the way the children filed was defined already made them a property, which means Groovy is so nice to generate a get method for us. No the really interesting part is <code>NodeType1Counter</code>, it is interesting because we have not changed it. <code>super.visit(n1)</code> will now call <code>visit(Visitable)</code> which will call <code>doIteration</code> which will start the next level of iteration. So no change. But <code>visit(it)</code> will call <code>visit(NodeType1)</code> if it is of type <code>NodeType1</code>. In fact we don&#8217;t need the <code>doIteration</code> method, we could do that in <code>visit(Visitable)</code> too, but I thought this variant is better, because it allows us to write a new <code>Visitor</code> that overwrites visit(<code>Visitable</code>) for error cases which of course means we must not do <code>super.visit(n1)</code> but <code>doIteration(n1)</code>.</p>
</div>
</div>
<div class="sect6">
<h7 id="_summary">Summary</h7>
<div class="paragraph">
<p>In the end we got ~40% less code, a robust and stable architecture and we completely removed the Visitor from the Visitable. I heard about visitor implementations based on Reflection to get a more generic version. Well, with this you see there is really no need to do such thing. If we add new types we don&#8217;t need to change anything. It is said that the visitor pattern doesn&#8217;t fit extreme programming techniques very well because you need to make changes to so many classes all the time. I think I proved that this is because of Java not because the pattern is bad or something.</p>
</div>
<div class="paragraph">
<p>There are variants of the Visitor pattern, like the acyclic visitor pattern, that tries to solve the problem of adding new node types with special visitors. I don&#8217;t like that very much, it works with casts, catches the <code>ClassCastException</code> and other nasty things. In the end it tries to solve something we don&#8217;t even get with the Groovy version.</p>
</div>
<div class="paragraph">
<p>One more thing. <code>NodeType1Counter</code> could be implemented in Java as well. Groovy will recognize the visit methods and call them as needed because <code>DefaultVisitor</code> is still Groovy and does all the magic.</p>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_further_information_2">Further Information</h6>
<div class="ulist">
<ul>
<li>
<p><a href="http://se.ethz.ch/~meyer/publications/computer/visitor.pdf">Componentization: the Visitor example</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_references">1.19. References</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides (1995). <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>. Addison-Wesley. ISBN 0-201-63361-2.</p>
<div class="ulist">
<ul>
<li>
<p><em>The canonical reference of design patterns.</em></p>
</li>
</ul>
</div>
</li>
<li>
<p>Martin Fowler (1999). <em>Refactoring: Improving the Design of Existing Code</em>. Addison-Wesley. ISBN 0-201-48567-2.</p>
</li>
<li>
<p>Joshua Kerievsky (2004). <em>Refactoring To Patterns</em>. Addison-Wesley. ISBN 0-321-21335-1.</p>
</li>
<li>
<p>Eric Freeman, Elisabeth Freeman, Kathy Sierra, Bert Bates (2004). <em>Head First Design Patterns</em>. O’Reilly. ISBN 0-596-00712-4.
*<em>A great book to read, informative as well as amusing.</em></p>
</li>
<li>
<p>Dierk Koenig with Andrew Glover, Paul King, Guillaume Laforge and Jon Skeet (2007). <em>Groovy in Action</em>. Manning. ISBN 1-932394-84-2.</p>
<div class="ulist">
<ul>
<li>
<p><em>Discusses Visitor, Builder and other Patterns.</em></p>
</li>
</ul>
</div>
</li>
<li>
<p>Brad Appleton (1999). <a href="http://www.bradapp.com/docs/pizza-inv.html">Pizza Inversion - a Pattern for Efficient Resource Consumption</a>.</p>
<div class="ulist">
<ul>
<li>
<p><em>One of the most frequently used patterns by many software engineers!</em></p>
</li>
</ul>
</div>
</li>
<li>
<p><em>Design Patterns in Dynamic Languages</em> by Neil Ford. Houston Java User’s Group. Examples in Groovy and Ruby. <a href="http://www.hjug.org/present/Neal_Ford-Design_Patterns_in_Dynamic_Languages-slides.pdf">http://www.hjug.org/present/Neal_Ford-Design_Patterns_in_Dynamic_Languages-slides.pdf</a></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>See also: <a href="#_refactoring_bwith_groovy">Refactoring with Groovy</a>.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 2.4.0-SNAPSHOT<br>
Last updated 2014-07-16 00:29:12 CST
</div>
</div>
</body>
</html>